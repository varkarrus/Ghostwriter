<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>GhostWriter — Drive-only + Markdown + JSON Header</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <!-- Google Identity Services (OAuth in browser) -->
  <script src="https://accounts.google.com/gsi/client" async defer></script>
  <style>
    :root { --bg:#ffffff; --muted:#f6f6f6; --line:#e8e8e8; --ink:#111; --sub:#555; --meta-w: 380px; }
    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body { margin: 0; background: var(--bg); color: var(--ink); font: 14px/1.45 system-ui, -apple-system, Segoe UI, Roboto, sans-serif; }

    /* App shell: header • main • footer */
    .app { display: grid; grid-template-rows: auto 1fr auto; height: 100vh; }
    header, footer { background: var(--muted); border-bottom: 1px solid var(--line); }
    footer { border-top: 1px solid var(--line); border-bottom: none; font-size: 12px; color: var(--sub); padding: 10px 14px; display:flex; gap:10px; align-items:center; }

    /* Toolbar */
    .toolbar { padding: 10px 14px; display: flex; gap: 8px; flex-wrap: wrap; align-items: center; }
    .toolbar .row { display: flex; align-items: center; gap: 8px; flex-wrap: wrap; }
    .toolbar button, .toolbar select { padding: 8px 10px; border: 1px solid var(--line); background: #fff; border-radius: 10px; cursor: pointer; }
    .toolbar button[disabled] { opacity: 0.5; cursor: not-allowed; }
    .toolbar input[type="text"] { flex: 1; min-width: 220px; padding: 8px; border-radius: 10px; border: 1px solid var(--line); background: #fff; }

    /* File list dropdown */
    #list-panel { max-height: 40vh; overflow: auto; border-top: 1px solid var(--line); background: #fff; display: none; }
    #list-panel table { width: 100%; border-collapse: collapse; font-size: 13px; }
    #list-panel th, #list-panel td { padding: 8px 12px; border-bottom: 1px solid var(--line); }
    #list-panel tr:hover { background: #fafafa; }

    /* Main editor/preview area */
    main.main { display: grid; grid-template-columns: 1fr; height: 100%; min-height: 0; }
    #editor-wrap, #preview { min-height: 0; }
    #editor { width: 100%; height: 100%; padding: 16px; border: none; outline: none; resize: none; font: 14px/1.5 ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; }
    #preview { display:none; padding: 18px; overflow:auto; background:#fff; border-left: 1px solid var(--line); }

    /* Split / Preview-only modes */
    body[data-mode="split"] main.main { grid-template-columns: 1fr 1fr; }
    body[data-mode="split"] #preview { display:block; }
    body[data-mode="preview"] #editor-wrap { display:none; }
    body[data-mode="preview"] #preview { display:block; }

    /* Preview typography */
    #preview h1, #preview h2, #preview h3, #preview h4, #preview h5, #preview h6 { margin: 1.2em 0 0.5em; line-height:1.2; }
    #preview h1 { font-size: 1.6rem; }
    #preview h2 { font-size: 1.4rem; }
    #preview h3 { font-size: 1.25rem; }
    #preview p { margin: 0.5em 0; }
    #preview ul { margin: 0.5em 0 0.5em 1.2em; }
    #preview li { margin: 0.25em 0; }

    .pill { display: inline-block; padding: 3px 10px; border-radius: 999px; background: #eee; font-size: 12px; }
    a { color: inherit; }
    code.kbd { padding: 2px 6px; border: 1px solid var(--line); border-radius: 6px; background: #fbfbfb; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; }
    .dot { width:8px; height:8px; border-radius:999px; background:#bbb; display:inline-block; }
    .dot.saving { background:#d69e2e; }
    .dot.saved { background:#38a169; }
    .dot.idle { background:#bbb; }

    /* ========================= */
    /* Side Metadata Panel (Drawer) */
    /* ========================= */
    #meta-panel {
      position: fixed;
      top: 0; right: 0;
      height: 100vh; width: var(--meta-w);
      background: #fff;
      border-left: 1px solid var(--line);
      box-shadow: -8px 0 24px rgba(0,0,0,0.06);
      transform: translateX(100%);
      transition: transform 220ms ease;
      z-index: 50;
      display: grid;
      grid-template-rows: auto 1fr auto;
    }
    #meta-panel[data-open="1"] { transform: translateX(0); }

    /* Panel header */
    #meta-head { display: flex; align-items: center; justify-content: space-between; gap: 8px; padding: 10px 12px; border-bottom: 1px solid var(--line); background: var(--muted); }
    #meta-title { font-size: 13px; color: #333; font-weight: 600; }
    #meta-close, #meta-toggle, #meta-save-now { padding: 6px 10px; border: 1px solid var(--line); background:#fff; border-radius: 8px; cursor: pointer; }

    /* Panel body */
    #meta-body { padding: 10px 12px; overflow: auto; display: grid; gap: 10px; }
    #meta-body .row { display:grid; grid-template-columns: 1fr; gap: 6px; }
    #meta-body label { font-size: 12px; color: #333; }
    #meta-body textarea { width: 100%; min-height: 100px; max-height: 45vh; padding: 8px; resize: vertical; border: 1px solid var(--line); border-radius: 8px; font: 13px/1.45 ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; }
    #meta-body input[type="password"], #meta-body select { width: 100%; padding: 8px; border: 1px solid var(--line); border-radius: 8px; font: 13px/1.45 system-ui, -apple-system, Segoe UI, Roboto, sans-serif; }
    #meta-body input[type="password"] { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; }
    #meta-body button { padding: 10px 12px; border: 1px solid var(--line); background: #fff; border-radius: 8px; cursor: pointer; font: 13px/1.45 system-ui, -apple-system, Segoe UI, Roboto, sans-serif; font-weight: 600; }
    #meta-body button:hover:not(:disabled) { background: var(--muted); }
    #meta-body button:disabled { opacity: 0.5; cursor: not-allowed; }
    #meta-body button.generating { background: #f0f8ff; border-color: #4a90e2; }
    #next-enable-wrap { display:flex; align-items:center; justify-content:flex-end; gap: 8px; }

    /* Panel footer */
    #meta-foot { padding: 8px 12px; border-top: 1px solid var(--line); font-size:12px; color: var(--sub); display:flex; justify-content: space-between; align-items:center; gap: 8px; }

    /* Scrim behind drawer */
    #meta-scrim {
      position: fixed; inset: 0; background: rgba(0,0,0,0.18);
      opacity: 0; pointer-events: none; transition: opacity 200ms ease; z-index: 40;
    }
    #meta-scrim[data-open="1"] { opacity: 1; pointer-events: auto; }

    /* Side tab button */
    #meta-tab {
      position: fixed; right: 0; top: 50%; transform: translate(50%, -50%);
      writing-mode: vertical-rl; text-orientation: mixed;
      background: #fff; border: 1px solid var(--line); border-right: none; border-radius: 10px 0 0 10px;
      padding: 10px 8px; font-size: 12px; cursor: pointer; z-index: 60;
      box-shadow: -4px 4px 12px rgba(0,0,0,0.06);
    }
    #meta-tab[aria-disabled="true"] { opacity: 0.5; cursor: not-allowed; }

    /* Responsive niceties */
    @media (max-width: 480px) {
      :root { --meta-w: 92vw; }
      #meta-tab { top: auto; bottom: 18px; transform: translate(50%, 0); writing-mode: horizontal-tb; }
    }
  </style>
</head>
<body data-mode="edit">
<div class="app">
  <header>
    <div class="toolbar">
      <div class="row">
        <button id="auth-btn">Sign in</button>
        <button id="signout-btn" disabled>Sign out</button>
        <span class="pill" id="auth-state">Signed out</span>
      </div>
      <div class="row">
        <button id="create-file-btn" disabled>Create new file</button>
        <input id="file-id-input" type="text" placeholder="Paste File ID and press Enter (or use ?file=...)" />
        <button id="list-btn" disabled>My files</button>
      </div>
      <div class="row" id="formatting-row" title="Formatting inserts Markdown/HTML into the plaintext">
        <button id="bold-btn" aria-label="Bold (Ctrl/⌘+B)"><strong>B</strong></button>
        <button id="italic-btn" aria-label="Italic (Ctrl/⌘+I)"><em>I</em></button>
        <button id="underline-btn" aria-label="Underline (Ctrl/⌘+U)"><u>U</u></button>
        <button id="bullet-btn" aria-label="Bulleted list (Ctrl/⌘+Shift+8)">• List</button>
        <label for="heading-select" class="pill" style="background:#fff;border:1px solid var(--line)">Hdr</label>
        <select id="heading-select" aria-label="Heading">
          <option value="0">Paragraph</option>
          <option value="1">H1</option>
          <option value="2">H2</option>
          <option value="3">H3</option>
          <option value="4">H4</option>
          <option value="5">H5</option>
          <option value="6">H6</option>
        </select>
        <button id="toggle-preview">Preview</button>
        <button id="toggle-split">Split</button>
      </div>
    </div>
    <div id="list-panel">
      <table>
        <thead><tr><th style="width:45%">Name</th><th style="width:35%">Modified</th><th style="width:20%">Actions</th></tr></thead>
        <tbody id="list-body"></tbody>
      </table>
    </div>
  </header>

  <main class="main">
    <div id="editor-wrap">
      <textarea id="editor" placeholder="Write your story here…"></textarea>
    </div>
    <div id="preview" aria-live="polite"></div>
  </main>

  <footer>
    <span id="status">Ready.</span>
    <span id="active-file"></span>
    <span class="dot idle" id="save-indicator" title="Save status"></span>
    <span class="pill" id="sync-note"></span>
  </footer>
</div>

<!-- Side tab and drawer -->
<button id="meta-tab" aria-expanded="false" aria-controls="meta-panel" title="Metadata (Alt+M)">Metadata</button>
<div id="meta-scrim" aria-hidden="true"></div>
<aside id="meta-panel" role="complementary" aria-label="Story metadata" data-open="0">
  <div id="meta-head">
    <div id="meta-title">Story Metadata</div>
    <div style="display:flex; gap:6px; align-items:center;">
      <button id="meta-save-now" title="Save now (Ctrl/⌘+S)">Save</button>
      <button id="meta-close" title="Close (Esc)">Close</button>
    </div>
  </div>
  <div id="meta-body">
    <div class="row">
      <label for="ai-pre">AI Pre‑prompt</label>
      <textarea id="ai-pre" placeholder="System-style guidance for the model…"></textarea>
    </div>
    <div class="row">
      <label for="next-inst">Next Instructions</label>
      <textarea id="next-inst" placeholder="Steering for the next generation…"></textarea>
      <div id="next-enable-wrap">
        <label style="display:flex;align-items:center;gap:6px;"><input type="checkbox" id="next-enabled" /> Enable</label>
      </div>
    </div>
    <div class="row">
      <label for="openrouter-key">OpenRouter API Key</label>
      <input type="password" id="openrouter-key" placeholder="sk-or-v1-..." />
      <div style="display:flex;align-items:center;gap:6px;margin-top:4px;">
        <label style="display:flex;align-items:center;gap:6px;"><input type="checkbox" id="remember-key" /> Remember API key</label>
      </div>
    </div>
    <div class="row">
      <label for="ai-model">AI Model</label>
      <select id="ai-model">
        <option value="">Select a model...</option>
        <option value="anthropic/claude-3.5-sonnet">Claude 3.5 Sonnet</option>
        <option value="anthropic/claude-3-haiku">Claude 3 Haiku</option>
        <option value="openai/gpt-4o">GPT-4o</option>
        <option value="openai/gpt-4o-mini">GPT-4o Mini</option>
        <option value="meta-llama/llama-3.1-70b-instruct">Llama 3.1 70B</option>
        <option value="meta-llama/llama-3.1-8b-instruct">Llama 3.1 8B</option>
      </select>
    </div>
    <div class="row">
      <button id="ai-generate" type="button" disabled>Generate with AI</button>
    </div>
  </div>
  <div id="meta-foot">
    <div>Changes autosave with content. <span class="pill">Alt+M</span> toggles.</div>
    <div id="meta-hint" class="pill" style="background:#fff;border:1px solid var(--line)">Drive‑synced</div>
  </div>
</aside>

<script>
  // =========================
  //  Configuration
  // =========================
  const CLIENT_ID = "389780383024-03s13biqo3n1hvdv2mn8jb2fcvc17ks3.apps.googleusercontent.com"; // OAuth 2.0 Web client ID (public)
  const SCOPE = "https://www.googleapis.com/auth/drive.file https://www.googleapis.com/auth/drive.appdata"; // Drive scope + app data

  const DRIVE_UPLOAD_URL = "https://www.googleapis.com/upload/drive/v3/files";
  const DRIVE_FILES_URL  = "https://www.googleapis.com/drive/v3/files";
  
  // AI Settings
  const AI_SETTINGS_FILENAME = "ghostwriter-ai-settings.json";

  // Autosave + polling
  const AUTOSAVE_DELAY = 1200;  // ms after last keystroke
  const POLL_INTERVAL  = 8000;  // ms between remote checks
  const IDLE_GRACE     = 1200;  // ms considered "still typing"

  // File format sentinels for JSON header
  const META_START = ";;;GW:JSON-START";
  const META_END   = ";;;GW:JSON-END";

  const DEFAULT_META = {
    ai_pre_prompt: "",
    next_instructions: "",
    next_instructions_enabled: false,
    openrouter_key: "",
    remember_key: false,
    ai_model: ""
  };

  // =========================
  //  DOM
  // =========================
  const authBtn      = document.getElementById("auth-btn");
  const signoutBtn   = document.getElementById("signout-btn");
  const createBtn    = document.getElementById("create-file-btn");
  const listBtn      = document.getElementById("list-btn");
  const fileIdInput  = document.getElementById("file-id-input");
  const editor       = document.getElementById("editor");
  const statusEl     = document.getElementById("status");
  const authStateEl  = document.getElementById("auth-state");
  const activeFileEl = document.getElementById("active-file");
  const listPanel    = document.getElementById("list-panel");
  const listBody     = document.getElementById("list-body");
  const saveDot      = document.getElementById("save-indicator");
  const syncNote     = document.getElementById("sync-note");
  const boldBtn      = document.getElementById("bold-btn");
  const italicBtn    = document.getElementById("italic-btn");
  const underlineBtn = document.getElementById("underline-btn");
  const bulletBtn    = document.getElementById("bullet-btn");
  const headingSel   = document.getElementById("heading-select");
  const togglePreviewBtn = document.getElementById("toggle-preview");
  const toggleSplitBtn   = document.getElementById("toggle-split");
  const previewEl    = document.getElementById("preview");

  // Side panel elements
  const metaPanel    = document.getElementById("meta-panel");
  const metaScrim    = document.getElementById("meta-scrim");
  const metaTab      = document.getElementById("meta-tab");
  const metaClose    = document.getElementById("meta-close");
  const metaSaveNow  = document.getElementById("meta-save-now");

  const aiPreInput   = document.getElementById("ai-pre");
  const nextInstInput= document.getElementById("next-inst");
  const nextEnabled  = document.getElementById("next-enabled");
  const openrouterKey = document.getElementById("openrouter-key");
  const rememberKey  = document.getElementById("remember-key");
  const aiModel      = document.getElementById("ai-model");
  const aiGenerate   = document.getElementById("ai-generate");

  // =========================
  //  Auth & state
  // =========================
  let tokenClient = null;
  let accessToken = null; // kept in-memory only
  let currentFileId = null;
  let currentFileName = null;
  let autosaveTimer = null;
  let pollTimer = null;
  let isSaving = false;
  let dirty = false;           // local edits (editor or metadata) since last save
  let lastInputTs = 0;         // timestamp of last edit
  let lastRemoteModified = 0;  // ms
  
  // AI Settings state
  let aiSettingsFileId = null; // ID of the AI settings file in appdata folder
  let aiSettingsLoaded = false; // whether we've attempted to load AI settings
  let saveAISettingsTimer = null; // timer for delayed AI settings save

  function setStatus(msg) { statusEl.textContent = msg; }
  function setSaveDot(state) {
    saveDot.classList.remove("saving","saved","idle");
    saveDot.classList.add(state);
  }
  function setActiveFile(id, name) {
    currentFileId = id || null;
    currentFileName = name || null;
    fileIdInput.value = id || "";
    activeFileEl.textContent = id ? `• File: ${name || "(untitled)"} — ID: ${id}` : "";
  }
  function setSignedInUI(signedIn) {
    authStateEl.textContent = signedIn ? "Signed in" : "Signed out";
    createBtn.disabled = !signedIn;
    signoutBtn.disabled = !signedIn;
    listBtn.disabled = !signedIn;
    fileIdInput.disabled = !signedIn;
    [boldBtn, italicBtn, underlineBtn, bulletBtn, headingSel, togglePreviewBtn, toggleSplitBtn, aiPreInput, nextInstInput, nextEnabled, metaClose, metaSaveNow].forEach(el => el.disabled = !signedIn);
    metaTab.setAttribute('aria-disabled', String(!signedIn));
    if (!signedIn) openMeta(false);
  }
  function getQueryFileId() { const p = new URLSearchParams(location.search); return p.get("file"); }

  window.addEventListener("load", () => {
    const waitFor = (cond) => new Promise(res => { const t = () => cond() ? res() : setTimeout(t, 50); t(); });
    waitFor(() => window.google && google.accounts && google.accounts.oauth2).then(() => {
      tokenClient = google.accounts.oauth2.initTokenClient({
        client_id: CLIENT_ID,
        scope: SCOPE,
        callback: (resp) => {
          if (resp.error) { console.error(resp); setStatus("Auth error."); return; }
          accessToken = resp.access_token;
          setStatus("Signed in.");
          setSignedInUI(true);
          loadAISettings(); // Load saved AI settings after authentication
          const preset = getQueryFileId();
          if (preset) { fileIdInput.value = preset; loadFile(preset); }
        }
      });
      wireEvents();
      setStatus("Ready. Sign in to begin.");
      updateGenerateButton(); // Initialize AI button state
    }).catch(err => { console.error(err); setStatus("Failed to initialize Google Identity Services."); });
  });

  function ensureAuth(action, fn) {
    return () => {
      if (!accessToken) {
        setStatus(`Requesting permission for ${action}…`);
        tokenClient.requestAccessToken({ prompt: "consent" });
        return;
      }
      fn();
    };
  }

  function wireEvents() {
    document.getElementById("auth-btn").addEventListener("click", () => { setStatus("Opening Google sign-in…"); tokenClient.requestAccessToken({ prompt: "consent" }); });
    signoutBtn.addEventListener("click", () => {
      if (accessToken) {
        stopPolling();
        // Clear AI settings state on signout
        aiSettingsLoaded = false;
        aiSettingsFileId = null;
        if (!rememberKey.checked) {
          openrouterKey.value = "";
        }
        updateGenerateButton();
        google.accounts.oauth2.revoke(accessToken, () => { accessToken = null; setSignedInUI(false); setActiveFile(null, null); setStatus("Signed out."); });
      }
    });

    createBtn.addEventListener("click", ensureAuth("creating a file", createNewFile));

    fileIdInput.addEventListener("keydown", (e) => { if (e.key === "Enter") { const id = fileIdInput.value.trim(); if (id) ensureAuth("opening a file", () => loadFile(id))(); } });

    listBtn.addEventListener("click", ensureAuth("listing files", async () => { listPanel.style.display = listPanel.style.display === "none" ? "block" : "none"; if (listPanel.style.display === "block") { await refreshList(); } }));

    // Editor typing => autosave & preview
    editor.addEventListener("input", () => { markDirty(); updatePreview(); });

    // Metadata edits => autosave
    aiPreInput.addEventListener("input", () => { markDirty(); });
    nextInstInput.addEventListener("input", () => { markDirty(); });
    nextEnabled.addEventListener("change", () => { markDirty(); });
    openrouterKey.addEventListener("input", () => { 
      markDirty(); 
      updateGenerateButton(); 
      // Save API key after user stops typing (only if remember is checked)
      if (rememberKey.checked) {
        clearTimeout(saveAISettingsTimer);
        saveAISettingsTimer = setTimeout(() => saveAISettings(), 2000);
      }
    });
    rememberKey.addEventListener("change", () => { markDirty(); saveAISettings(); });
    aiModel.addEventListener("change", () => { markDirty(); updateGenerateButton(); saveAISettings(); });

    // Drawer open/close
    const toggle = () => openMeta(metaPanel.getAttribute('data-open') !== '1');
    metaTab.addEventListener('click', () => { if (metaTab.getAttribute('aria-disabled') === 'true') return; toggle(); });
    metaScrim.addEventListener('click', () => openMeta(false));
    metaClose.addEventListener('click', () => openMeta(false));

    // Keyboard shortcuts
    window.addEventListener("keydown", (e) => {
      const isMac = navigator.platform.toLowerCase().includes("mac");
      const primary = isMac ? e.metaKey : e.ctrlKey;
      if (primary && e.key.toLowerCase() === "s") { e.preventDefault(); flushSave(); return; }
      if (primary && e.key.toLowerCase() === "b") { e.preventDefault(); toggleBold(); return; }
      if (primary && e.key.toLowerCase() === "i") { e.preventDefault(); toggleItalic(); return; }
      if (primary && e.key.toLowerCase() === "u") { e.preventDefault(); toggleUnderline(); return; }
      if (primary && e.shiftKey && e.key === "8") { e.preventDefault(); toggleBulleted(); return; }
      if (primary && /^[1-6]$/.test(e.key)) { e.preventDefault(); toggleHeading(parseInt(e.key,10)); headingSel.value = e.key; return; }
      // Alt+M toggles metadata drawer
      if ((e.altKey || e.metaKey && e.shiftKey) && e.key.toLowerCase() === 'm') { e.preventDefault(); const wantOpen = metaPanel.getAttribute('data-open') !== '1'; openMeta(wantOpen); return; }
      if (e.key === 'Escape') { if (metaPanel.getAttribute('data-open') === '1') { e.preventDefault(); openMeta(false); } }
      if (e.key === "Tab") {
        const { start, end } = getSelection(editor);
        const lines = getSelectedLineRange(editor.value, start, end);
        if (lines.text.match(/^(\-\s|\s*)/m)) { e.preventDefault(); if (e.shiftKey) outdentSelection(); else indentSelection(); }
      }
    });

    // Formatting toolbar
    document.getElementById("bold-btn").addEventListener("click", () => { toggleBold(); updatePreview(); });
    document.getElementById("italic-btn").addEventListener("click", () => { toggleItalic(); updatePreview(); });
    document.getElementById("underline-btn").addEventListener("click", () => { toggleUnderline(); updatePreview(); });
    document.getElementById("bullet-btn").addEventListener("click", () => { toggleBulleted(); updatePreview(); });
    headingSel.addEventListener("change", () => { const lvl = parseInt(headingSel.value, 10); if (!isNaN(lvl)) { toggleHeading(lvl); updatePreview(); } });

    // Preview mode toggles
    togglePreviewBtn.addEventListener("click", () => { const mode = document.body.getAttribute("data-mode"); document.body.setAttribute("data-mode", mode === "preview" ? "edit" : "preview"); updatePreview(); });
    toggleSplitBtn.addEventListener("click", () => { const mode = document.body.getAttribute("data-mode"); document.body.setAttribute("data-mode", mode === "split" ? "edit" : "split"); updatePreview(); });

    // Save button in drawer
    metaSaveNow.addEventListener('click', () => flushSave());

    // AI Generate button
    aiGenerate.addEventListener('click', () => generateAIContent());

    window.addEventListener("visibilitychange", () => { if (document.visibilityState === "hidden") flushSave({ silent:true }); });
    window.addEventListener("beforeunload", () => { flushSave({ silent:true }); });
  }

  // Drawer controller
  function openMeta(open) {
    metaPanel.setAttribute('data-open', open ? '1' : '0');
    metaScrim.setAttribute('data-open', open ? '1' : '0');
    metaTab.setAttribute('aria-expanded', String(open));
    if (open) {
      // Focus the first editable input for speedy tweaking
      setTimeout(() => { aiPreInput.focus(); aiPreInput.setSelectionRange(aiPreInput.value.length, aiPreInput.value.length); }, 80);
    } else {
      metaTab.focus();
    }
  }

  // =========================
  //  JSON header <-> UI
  // =========================
  function readMetaFromUI(){
    return {
      ai_pre_prompt: aiPreInput.value || "",
      next_instructions: nextInstInput.value || "",
      next_instructions_enabled: !!nextEnabled.checked,
      openrouter_key: rememberKey.checked ? (openrouterKey.value || "") : "",
      remember_key: !!rememberKey.checked,
      ai_model: aiModel.value || ""
    };
  }
  function writeMetaToUI(meta){
    aiPreInput.value = meta.ai_pre_prompt || "";
    nextInstInput.value = meta.next_instructions || "";
    nextEnabled.checked = !!meta.next_instructions_enabled;
    openrouterKey.value = meta.openrouter_key || "";
    rememberKey.checked = !!meta.remember_key;
    aiModel.value = meta.ai_model || "";
    updateGenerateButton();
  }

  function buildFileText(meta, content){
    const json = JSON.stringify(meta, null, 2);
    return `${META_START}\n${json}\n${META_END}\n\n${content || ""}`;
  }
  function parseFileText(text){
    try {
      const s = text.indexOf(META_START);
      const e = text.indexOf(META_END);
      if (s !== -1 && e !== -1 && e > s){
        const jsonStr = text.slice(s + META_START.length, e).trim();
        const meta = JSON.parse(jsonStr);
        const after = text.slice(e + META_END.length).replace(/^\s*\n?/, "");
        return { meta: { ...DEFAULT_META, ...meta }, content: after };
      }
    } catch (err) { console.warn("Meta parse error; treating entire file as content.", err); }
    return { meta: { ...DEFAULT_META }, content: text };
  }

  // =========================
  //  Formatting helpers (Markdown-in-plaintext)
  // =========================
  function getSelection(el){ return { start: el.selectionStart, end: el.selectionEnd, value: el.value }; }
  function setSelection(el, start, end){ el.setSelectionRange(start, end); }
  function markDirty(){ dirty = true; lastInputTs = Date.now(); setSaveDot("saving"); scheduleAutosave(); }
  function applyChange(newValue, selStart, selEnd){ editor.value = newValue; setSelection(editor, selStart, selEnd); markDirty(); }

  function wrapOrUnwrapSelection(markerL, markerR, { altL = [], altR = [] } = {}){
    const { start, end, value } = getSelection(editor);
    const sel = value.slice(start, end); const before = value.slice(0, start); const after = value.slice(end);
    const allL = [markerL, ...altL]; const allR = [markerR, ...altR];
    const isWrapped = allL.some((L,i) => sel.startsWith(L) && sel.endsWith(allR[i] || markerR));
    if (isWrapped) {
      let unwrapped = sel;
      allL.forEach((L,i)=>{ const R = allR[i] || markerR; if (unwrapped.startsWith(L) && unwrapped.endsWith(R)) { unwrapped = unwrapped.slice(L.length, unwrapped.length - R.length); } });
      applyChange(before + unwrapped + after, start, start + unwrapped.length);
    } else {
      const insertL = markerL; const insertR = markerR;
      if (start === end) { const nv = before + insertL + insertR + after; const caret = (before + insertL).length; applyChange(nv, caret, caret); }
      else { const nv = before + insertL + sel + insertR + after; applyChange(nv, start + insertL.length, start + insertL.length + sel.length); }
    }
  }
  function toggleBold(){ wrapOrUnwrapSelection("**", "**", { altL:["__"], altR:["__"] }); }
  function toggleItalic(){ wrapOrUnwrapSelection("*", "*", { altL:["_"], altR:["_"] }); }
  function toggleUnderline(){ wrapOrUnwrapSelection("<u>", "</u>"); }

  function getSelectedLineRange(text, start, end){ const lineStart = text.lastIndexOf("\n", start - 1) + 1; let lineEnd = text.indexOf("\n", end); if (lineEnd === -1) lineEnd = text.length; return { start: lineStart, end: lineEnd, text: text.slice(lineStart, lineEnd) }; }
  function toggleBulleted(){ const { start, end, value } = getSelection(editor); const range = getSelectedLineRange(value, start, end); const lines = value.slice(range.start, range.end).split("\n"); const allBulleted = lines.every(l => /^\s*-\s/.test(l) || l.trim() === ""); const changed = lines.map(l => { if (l.trim() === "") return l; if (allBulleted) return l.replace(/^\s*-\s?/, ""); return l.replace(/^\s*/, "$&- "); }).join("\n"); const nv = value.slice(0, range.start) + changed + value.slice(range.end); const delta = changed.length - (range.end - range.start); applyChange(nv, start + (start - range.start), end + delta - (range.end - end)); }
  function toggleHeading(level){ const { start, end, value } = getSelection(editor); const range = getSelectedLineRange(value, start, end); const lines = range.text.split("\n"); const prefix = "#".repeat(Math.min(Math.max(level,0),6)); const changed = lines.map(l => { if (l.trim() === "") return l; const cur = l.match(/^\s*(#{1,6})\s+/); if (level === 0) { return cur ? l.replace(/^\s*#{1,6}\s+/, "") : l; } if (cur && cur[1].length === level) { return l.replace(/^\s*#{1,6}\s+/, ""); } return l.replace(/^\s*(#{1,6}\s+)?/, prefix + " "); }).join("\n"); const nv = value.slice(0, range.start) + changed + value.slice(range.end); const delta = changed.length - (range.end - range.start); applyChange(nv, start, end + delta); }
  function indentSelection(){ const { start, end, value } = getSelection(editor); const range = getSelectedLineRange(value, start, end); const lines = range.text.split("\n"); const changed = lines.map(l => l.trim() === "" ? l : "  " + l).join("\n"); const nv = value.slice(0, range.start) + changed + value.slice(range.end); const delta = changed.length - (range.end - range.start); applyChange(nv, start + 2, end + delta + 2); }
  function outdentSelection(){ const { start, end, value } = getSelection(editor); const range = getSelectedLineRange(value, start, end); const lines = range.text.split("\n"); const changed = lines.map(l => l.replace(/^ {1,2}/, "")).join("\n"); const nv = value.slice(0, range.start) + changed + value.slice(range.end); const delta = changed.length - (range.end - range.start); applyChange(nv, Math.max(range.start, start - 2), Math.max(range.start, end + delta - 2)); }

  // =========================
  //  Markdown renderer (safe-ish)
  // =========================
  function escapeHtml(str){ return String(str).replaceAll('&','&amp;').replaceAll('<','&lt;').replaceAll('>','&gt;'); }
  function applyInline(md){ let s = escapeHtml(md); s = s.replace(/\*\*([^\n*]+)\*\*/g, '<strong>$1</strong>'); s = s.replace(/(^|[^*])\*([^\n*]+)\*(?!\*)/g, '$1<em>$2</em>'); s = s.replace(/&lt;u&gt;([\s\S]*?)&lt;\/u&gt;/g, '<u>$1</u>'); return s; }
  function renderMarkdown(md){ const lines = md.replace(/\r\n/g,'\n').split('\n'); let html = ''; let inList = false; const flushList = () => { if (inList) { html += '</ul>'; inList = false; } }; for (let i=0;i<lines.length;i++){ const line = lines[i]; const h = line.match(/^(#{1,6})\s+(.*)$/); if (h){ flushList(); const lvl = h[1].length; const text = h[2]; html += `<h${lvl}>${applyInline(text)}</h${lvl}>`; continue; } const b = line.match(/^\s*-\s+(.*)$/); if (b){ if (!inList){ html += '<ul>'; inList = true; } html += `<li>${applyInline(b[1])}</li>`; continue; } if (/^\s*$/.test(line)) { flushList(); html += '<br />'; continue; } flushList(); html += `<p>${applyInline(line)}</p>`; } flushList(); return sanitizeHTML(html); }
  function sanitizeHTML(html){ const allowed = new Set(['H1','H2','H3','H4','H5','H6','P','STRONG','EM','U','UL','LI','BR']); const tmp = document.createElement('div'); tmp.innerHTML = html; (function walk(node){ const children = Array.from(node.childNodes); for (const child of children){ if (child.nodeType === 1){ if (!allowed.has(child.tagName)){ while (child.firstChild) node.insertBefore(child.firstChild, child); node.removeChild(child); continue; } const attrs = Array.from(child.attributes); for (const a of attrs) child.removeAttribute(a.name); walk(child); } } })(tmp); return tmp.innerHTML; }
  function updatePreview(){ previewEl.innerHTML = renderMarkdown(editor.value || ''); }

  // =========================
  //  AI Helper Functions
  // =========================
  function updateGenerateButton() {
    const hasKey = openrouterKey.value.trim().length > 0;
    const hasModel = aiModel.value.trim().length > 0;
    aiGenerate.disabled = !hasKey || !hasModel;
  }

  async function generateAIContent() {
    if (!openrouterKey.value.trim() || !aiModel.value.trim()) {
      setStatus("Please enter OpenRouter API key and select a model.");
      return;
    }

    try {
      setStatus("Generating AI content...");
      aiGenerate.disabled = true;
      aiGenerate.textContent = "Generating...";
      aiGenerate.classList.add("generating");

      // Get the current editor content
      const currentContent = editor.value || "";
      
      // Build the prompt
      let prompt = "";
      if (aiPreInput.value.trim()) {
        prompt += `[${aiPreInput.value.trim()}]\n\n`;
      }
      prompt += currentContent;
      
      // Add next instructions if enabled - append to most recent complete paragraph
      if (nextEnabled.checked && nextInstInput.value.trim()) {
        // Find paragraphs (separated by double newlines or end of text)
        const paragraphs = currentContent.split(/\n\s*\n/).filter(p => p.trim());
        if (paragraphs.length > 0) {
          // Check if the last paragraph looks complete (ends with punctuation)
          const lastParagraph = paragraphs[paragraphs.length - 1].trim();
          if (lastParagraph && /[.!?]$/.test(lastParagraph)) {
            prompt += `\n\n[${nextInstInput.value.trim()}]`;
          } else {
            // If no complete paragraph, just add instructions at the end
            prompt += `\n\n[${nextInstInput.value.trim()}]`;
          }
        } else {
          // No paragraphs yet, add instructions
          prompt += `\n\n[${nextInstInput.value.trim()}]`;
        }
      }

      // Call OpenRouter API
      const response = await fetch("https://openrouter.ai/api/v1/chat/completions", {
        method: "POST",
        headers: {
          "Authorization": `Bearer ${openrouterKey.value.trim()}`,
          "Content-Type": "application/json",
          "HTTP-Referer": window.location.origin,
          "X-Title": "Ghostwriter"
        },
        body: JSON.stringify({
          model: aiModel.value,
          messages: [
            {
              role: "user",
              content: prompt
            }
          ],
          max_tokens: 1000,
          temperature: 0.7
        })
      });

      if (!response.ok) {
        const errorText = await response.text();
        throw new Error(`OpenRouter API error: ${response.status} ${response.statusText}${errorText ? ' - ' + errorText : ''}`);
      }

      const data = await response.json();
      const generatedText = data.choices?.[0]?.message?.content?.trim();

      if (!generatedText) {
        throw new Error("No content generated from AI model.");
      }

      // Insert the generated content at the cursor position or end of editor
      const { start, end } = getSelection(editor);
      const before = editor.value.slice(0, start);
      const after = editor.value.slice(end);
      
      // Add appropriate spacing
      let insertText = generatedText;
      if (before && !before.endsWith('\n\n')) {
        insertText = '\n\n' + insertText;
      }
      
      const newValue = before + insertText + after;
      const newCursorPos = start + insertText.length;
      
      applyChange(newValue, newCursorPos, newCursorPos);
      updatePreview();
      
      setStatus("AI content generated successfully.");
    } catch (error) {
      console.error("AI generation error:", error);
      setStatus(`AI generation failed: ${error.message}`);
    } finally {
      aiGenerate.disabled = false;
      aiGenerate.textContent = "Generate with AI";
      aiGenerate.classList.remove("generating");
      updateGenerateButton();
    }
  }

  // =========================
  //  AI Settings Persistence (Google Drive AppData)
  // =========================
  async function findAISettingsFile() {
    try {
      const url = new URL(DRIVE_FILES_URL);
      url.searchParams.set("q", `name='${AI_SETTINGS_FILENAME}' and parents in 'appdata'`);
      url.searchParams.set("spaces", "appdata");
      url.searchParams.set("fields", "files(id,name)");
      
      const res = await fetch(url.toString(), { headers: authHeader() });
      if (res.status === 401) { await refreshToken(); return findAISettingsFile(); }
      if (!res.ok) throw new Error(`Find AI settings failed: ${res.status}`);
      
      const { files } = await res.json();
      return files && files.length > 0 ? files[0].id : null;
    } catch (e) {
      console.warn("Failed to find AI settings file:", e);
      return null;
    }
  }

  async function loadAISettings() {
    if (!accessToken || aiSettingsLoaded) return;
    
    try {
      aiSettingsFileId = await findAISettingsFile();
      if (!aiSettingsFileId) {
        aiSettingsLoaded = true;
        return; // No settings file exists yet
      }

      const res = await fetch(`${DRIVE_FILES_URL}/${aiSettingsFileId}?alt=media`, { headers: authHeader() });
      if (res.status === 401) { await refreshToken(); return loadAISettings(); }
      if (!res.ok) throw new Error(`Load AI settings failed: ${res.status}`);
      
      const settingsText = await res.text();
      const settings = JSON.parse(settingsText);
      
      // Apply settings to UI (but only if remember_key is true for API key)
      if (settings.ai_model) {
        aiModel.value = settings.ai_model;
      }
      if (settings.remember_key && settings.openrouter_key) {
        openrouterKey.value = settings.openrouter_key;
        rememberKey.checked = true;
      } else {
        rememberKey.checked = false;
      }
      
      updateGenerateButton();
      aiSettingsLoaded = true;
      console.log("AI settings loaded from Drive");
    } catch (e) {
      console.warn("Failed to load AI settings:", e);
      aiSettingsLoaded = true;
    }
  }

  async function saveAISettings() {
    if (!accessToken) return;
    
    try {
      const settings = {
        ai_model: aiModel.value || "",
        remember_key: !!rememberKey.checked,
        openrouter_key: rememberKey.checked ? (openrouterKey.value || "") : "",
        last_updated: new Date().toISOString()
      };
      
      const settingsJson = JSON.stringify(settings, null, 2);
      
      if (aiSettingsFileId) {
        // Update existing file
        const res = await fetch(`${DRIVE_UPLOAD_URL}/${aiSettingsFileId}?uploadType=media`, {
          method: "PATCH",
          headers: { ...authHeader(), "Content-Type": "application/json; charset=UTF-8" },
          body: settingsJson
        });
        if (res.status === 401) { await refreshToken(); return saveAISettings(); }
        if (!res.ok) throw new Error(`Update AI settings failed: ${res.status}`);
      } else {
        // Create new file in appdata folder
        const boundary = "-------AISettings-" + Math.random().toString(36).slice(2);
        const metadata = { 
          name: AI_SETTINGS_FILENAME, 
          parents: ["appdata"],
          mimeType: "application/json"
        };
        const body = `--${boundary}\r\n` +
          `Content-Type: application/json; charset=UTF-8\r\n\r\n` +
          JSON.stringify(metadata) + `\r\n` +
          `--${boundary}\r\n` +
          `Content-Type: application/json; charset=UTF-8\r\n\r\n` +
          settingsJson + `\r\n` +
          `--${boundary}--`;
          
        const res = await fetch(`${DRIVE_UPLOAD_URL}?uploadType=multipart&fields=id`, {
          method: "POST",
          headers: { ...authHeader(), "Content-Type": `multipart/related; boundary=${boundary}` },
          body
        });
        if (res.status === 401) { await refreshToken(); return saveAISettings(); }
        if (!res.ok) throw new Error(`Create AI settings failed: ${res.status}`);
        
        const result = await res.json();
        aiSettingsFileId = result.id;
      }
      
      console.log("AI settings saved to Drive");
    } catch (e) {
      console.warn("Failed to save AI settings:", e);
    }
  }

  // =========================
  //  Drive helpers (fetch)
  // =========================
  function authHeader() { return { Authorization: `Bearer ${accessToken}` }; }
  async function createTextFile(name, text) { const boundary = "-------Ghostwriter-" + Math.random().toString(36).slice(2); const metadata = { name, mimeType: "text/plain", appProperties: { Ghostwriter: "1" } }; const body = `--${boundary}\r\n` + `Content-Type: application/json; charset=UTF-8\r\n\r\n` + JSON.stringify(metadata) + `\r\n` + `--${boundary}\r\n` + `Content-Type: text/plain; charset=UTF-8\r\n\r\n` + (text || "") + `\r\n` + `--${boundary}--`; const res = await fetch(`${DRIVE_UPLOAD_URL}?uploadType=multipart&fields=id,name,webViewLink,modifiedTime`, { method: "POST", headers: { ...authHeader(), "Content-Type": `multipart/related; boundary=${boundary}` }, body }); if (res.status === 401) { await refreshToken(); return createTextFile(name, text); } if (!res.ok) throw new Error(`Create failed: ${res.status}`); return await res.json(); }
  async function updateTextFile(fileId, text) { const res = await fetch(`${DRIVE_UPLOAD_URL}/${fileId}?uploadType=media&fields=id,name,modifiedTime,webViewLink`, { method: "PATCH", headers: { ...authHeader(), "Content-Type": "text/plain; charset=UTF-8" }, body: text || "" }); if (res.status === 401) { await refreshToken(); return updateTextFile(fileId, text); } if (!res.ok) throw new Error(`Update failed: ${res.status}`); return await res.json(); }
  async function downloadTextFile(fileId) { const res = await fetch(`${DRIVE_FILES_URL}/${fileId}?alt=media`, { headers: authHeader() }); if (res.status === 401) { await refreshToken(); return downloadTextFile(fileId); } if (!res.ok) throw new Error(`Download failed: ${res.status}`); return await res.text(); }
  async function getMeta(fileId) { const res = await fetch(`${DRIVE_FILES_URL}/${fileId}?fields=id,name,modifiedTime`, { headers: authHeader() }); if (res.status === 401) { await refreshToken(); return getMeta(fileId); } if (!res.ok) throw new Error(`Meta failed: ${res.status}`); return await res.json(); }
  async function listGhostwriterFiles() { const q = ["mimeType='text/plain'","appProperties has { key='Ghostwriter' and value='1' }"]; const url = new URL(DRIVE_FILES_URL); url.searchParams.set("q", q.join(" and ")); url.searchParams.set("orderBy", "modifiedTime desc"); url.searchParams.set("pageSize", "100"); url.searchParams.set("fields", "files(id,name,modifiedTime)"); const res = await fetch(url.toString(), { headers: authHeader() }); if (res.status === 401) { await refreshToken(); return listGhostwriterFiles(); } if (!res.ok) throw new Error(`List failed: ${res.status}`); const { files } = await res.json(); return files || []; }
  async function refreshToken(){ return new Promise((resolve) => { tokenClient.callback = () => resolve(); tokenClient.requestAccessToken({ prompt: "" }); }); }

  // =========================
  //  App actions (now include JSON header)
  // =========================
  async function createNewFile() {
    try {
      setStatus("Creating file…");
      const title = `GhostWriter ${new Date().toISOString().replace(/[:.]/g, "-")}.txt`;
      const combined = buildFileText(readMetaFromUI(), editor.value || "");
      const meta = await createTextFile(title, combined);
      setActiveFile(meta.id, meta.name);
      lastRemoteModified = Date.parse(meta.modifiedTime || Date.now());
      startPolling();
      setStatus("File created and syncing.");
      const u = new URL(location.href); u.searchParams.set("file", meta.id); history.replaceState({}, "", u.toString());
      updatePreview();
    } catch (e) { console.error(e); setStatus("Failed to create file. See console."); }
  }

  async function loadFile(id) {
    try {
      setStatus("Loading file…");
      const meta = await getMeta(id);
      const raw = await downloadTextFile(id);
      const parsed = parseFileText(raw);
      writeMetaToUI(parsed.meta);
      editor.value = parsed.content;
      setActiveFile(id, meta.name || "(unknown)");
      lastRemoteModified = Date.parse(meta.modifiedTime || 0);
      startPolling();
      setStatus("Loaded and syncing.");
      const u = new URL(location.href); u.searchParams.set("file", id); history.replaceState({}, "", u.toString());
      updatePreview();
    } catch (e) { console.error(e); setStatus("Failed to load file. Check ID and permissions."); }
  }

  function scheduleAutosave(){ clearTimeout(autosaveTimer); autosaveTimer = setTimeout(() => flushSave(), AUTOSAVE_DELAY); }

  async function flushSave(opts={}) {
    if (!currentFileId || !accessToken) return;
    if (!dirty && !opts.force) return;
    try {
      isSaving = true; setSaveDot("saving"); if (!opts.silent) setStatus("Saving…");
      const combined = buildFileText(readMetaFromUI(), editor.value);
      const res = await updateTextFile(currentFileId, combined);
      lastRemoteModified = Date.parse(res.modifiedTime || Date.now());
      dirty = false; isSaving = false; setSaveDot("saved"); if (!opts.silent) setStatus("Saved.");
      syncNote.textContent = `Auto-saved at ${new Date().toLocaleTimeString()}`;
      setTimeout(() => { if (!dirty) setSaveDot("idle"); }, 1200);
    } catch (e) { console.error(e); isSaving = false; setSaveDot("idle"); setStatus("Save failed. Will retry on next edit."); }
  }

  function startPolling(){ stopPolling(); pollTimer = setInterval(checkRemoteChanges, POLL_INTERVAL); }
  function stopPolling(){ if (pollTimer) clearInterval(pollTimer); pollTimer = null; }

  async function checkRemoteChanges(){
    if (!currentFileId || !accessToken) return;
    const now = Date.now();
    if (isSaving) return;
    if (dirty && now - lastInputTs < IDLE_GRACE) return;
    try {
      const meta = await getMeta(currentFileId);
      const remoteTs = Date.parse(meta.modifiedTime || 0);
      if (remoteTs > lastRemoteModified && !dirty) {
        const raw = await downloadTextFile(currentFileId);
        const parsed = parseFileText(raw);
        writeMetaToUI(parsed.meta);
        editor.value = parsed.content;
        lastRemoteModified = remoteTs;
        syncNote.textContent = `Updated from Drive at ${new Date().toLocaleTimeString()}`;
        setStatus("Pulled latest changes from Drive.");
        updatePreview();
      }
    } catch (e) { console.warn("Polling error", e); }
  }

  async function refreshList() {
    try { setStatus("Listing files…"); const files = await listGhostwriterFiles(); listBody.innerHTML = files.map(f => { const when = new Date(f.modifiedTime).toLocaleString(); const openHere = `<button data-open="${f.id}">Open here</button>`; const link = `https://drive.google.com/file/d/${f.id}/view`; return `<tr><td>${escapeHtml(f.name)}</td><td>${when}</td><td>${openHere} <a href="${link}" target="_blank" rel="noreferrer">Drive</a></td></tr>`; }).join(""); listBody.querySelectorAll("button[data-open]").forEach(btn => { btn.addEventListener("click", () => loadFile(btn.getAttribute("data-open"))); }); setStatus("Ready."); } catch (e) { console.error(e); setStatus("List failed. See console."); }
  }

  // NOTE: This overrides the earlier one (intentionally more strict for list rendering)
  function escapeHtml(str){ return String(str).replaceAll('&','&amp;').replaceAll('<','&lt;').replaceAll('>','&gt;').replaceAll('"','&quot;').replaceAll("'", '&#039;'); }
</script>
</body>
</html>
