<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>GhostWriter</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <!-- Google Identity Services (OAuth in browser) -->
  <script src="https://accounts.google.com/gsi/client" async defer></script>
  <style>
    :root { --bg:#ffffff; --muted:#f6f6f6; --line:#e8e8e8; --ink:#111; --sub:#555; --meta-w: 380px; }
    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body { margin: 0; background: var(--bg); color: var(--ink); font: 14px/1.45 system-ui, -apple-system, Segoe UI, Roboto, sans-serif; }

    /* App shell: header • main • footer */
    .app { display: grid; grid-template-rows: auto 1fr auto; height: 100vh; }
    header, footer { background: var(--muted); border-bottom: 1px solid var(--line); }
    footer { border-top: 1px solid var(--line); border-bottom: none; font-size: 12px; color: var(--sub); padding: 10px 14px; display:flex; gap:10px; align-items:center; }

    /* Toolbar */
    .toolbar { padding: 10px 14px; display: flex; gap: 8px; flex-wrap: wrap; align-items: center; }
    .toolbar .row { display: flex; align-items: center; gap: 8px; flex-wrap: wrap; }
    .toolbar button, .toolbar select { padding: 8px 10px; border: 1px solid var(--line); background: #fff; border-radius: 10px; cursor: pointer; }
    .toolbar button[disabled] { opacity: 0.5; cursor: not-allowed; }
    .toolbar input[type="text"] { flex: 1; min-width: 220px; padding: 8px; border-radius: 10px; border: 1px solid var(--line); background: #fff; }

    /* File list dropdown */
    #list-panel { max-height: 40vh; overflow: auto; border-top: 1px solid var(--line); background: #fff; display: none; }
    #list-panel table { width: 100%; border-collapse: collapse; font-size: 13px; }
    #list-panel th, #list-panel td { padding: 8px 12px; border-bottom: 1px solid var(--line); }
    #list-panel tr:hover { background: #fafafa; }

    /* Main editor/preview area */
    main.main { display: grid; grid-template-columns: 1fr; height: 100%; min-height: 0; width: 100%; margin: 0 auto; }
    #editor-wrap, #preview { min-height: 0; }
    #editor { 
      width: 100%; height: 100%; padding: 16px; border: none; outline: none; resize: none; 
      font: 14px/1.6 'SF Mono', Monaco, 'Cascadia Code', 'Roboto Mono', Consolas, 'Courier New', monospace;
      max-width: none;
    }
    #preview { display:none; padding: 18px; overflow:auto; background:#fff; border-left: 1px solid var(--line); }

    /* Responsive text area constraints */
    @media (min-width: 768px) {
      main.main { max-width: 1200px; margin: 0 auto; padding: 0 20px; }
      /* Add comfortable reading width for editor in non-split mode */
      body:not([data-mode="split"]) #editor { max-width: 800px; margin: 0 auto; }
    }
    @media (min-width: 1200px) {
      main.main { max-width: 1600px; padding: 0 40px; }
      body:not([data-mode="split"]) #editor { max-width: 900px; margin: 0 auto; }
    }
    @media (min-width: 1400px) {
      main.main { max-width: 1800px; padding: 0 60px; }
      body:not([data-mode="split"]) #editor { max-width: 1000px; margin: 0 auto; }
    }

    /* Split / Preview-only modes */
    body[data-mode="split"] main.main { grid-template-columns: 1fr 1fr; }
    body[data-mode="split"] #preview { display:block; }
    body[data-mode="preview"] #editor-wrap { display:none; }
    body[data-mode="preview"] #preview { display:block; }

    /* Preview typography */
    #preview h1, #preview h2, #preview h3, #preview h4, #preview h5, #preview h6 { margin: 1.2em 0 0.5em; line-height:1.2; }
    #preview h1 { font-size: 1.6rem; }
    #preview h2 { font-size: 1.4rem; }
    #preview h3 { font-size: 1.25rem; }
    #preview p { margin: 0.5em 0; }
    #preview ul { margin: 0.5em 0 0.5em 1.2em; }
    #preview li { margin: 0.25em 0; }

    .pill { display: inline-block; padding: 3px 10px; border-radius: 999px; background: #eee; font-size: 12px; }
    a { color: inherit; }
    code.kbd { padding: 2px 6px; border: 1px solid var(--line); border-radius: 6px; background: #fbfbfb; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; }
    .dot { width:8px; height:8px; border-radius:999px; background:#bbb; display:inline-block; }
    .dot.saving { background:#d69e2e; }
    .dot.saved { background:#38a169; }
    .dot.idle { background:#bbb; }

    /* ========================= */
    /* Side Metadata Panel (Drawer) */
    /* ========================= */
    #meta-panel {
      position: fixed;
      top: 0; right: 0;
      height: 100vh; width: var(--meta-w);
      background: #fff;
      border-left: 1px solid var(--line);
      box-shadow: -8px 0 24px rgba(0,0,0,0.06);
      transform: translateX(100%);
      transition: transform 220ms ease;
      z-index: 50;
      display: grid;
      grid-template-rows: auto auto 1fr auto;
    }
    #meta-panel[data-open="1"] { transform: translateX(0); }

    /* Panel header */
    #meta-head { display: flex; align-items: center; justify-content: space-between; gap: 8px; padding: 10px 12px; border-bottom: 1px solid var(--line); background: var(--muted); }
    #meta-title { font-size: 13px; color: #333; font-weight: 600; }
    #meta-close, #meta-toggle, #meta-save-now { padding: 6px 10px; border: 1px solid var(--line); background:#fff; border-radius: 8px; cursor: pointer; }

    /* Panel tabs */
    #meta-tabs {
      display: flex;
      border-bottom: 1px solid var(--line);
      background: var(--muted);
    }
    .meta-tab-btn {
      flex: 1 0 auto;
      padding: 6px 10px;
      border: none;
      background: transparent;
      font: 11px/1.3 system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      font-weight: 500;
      color: #666;
      cursor: pointer;
      border-bottom: 2px solid transparent;
      transition: all 150ms ease;
    }
    .meta-tab-btn:hover {
      background: rgba(255,255,255,0.5);
      color: #333;
    }
    .meta-tab-btn.active {
      background: #fff;
      color: #333;
      border-bottom-color: #4a90e2;
      font-weight: 600;
    }

    /* Panel body */
    #meta-body { padding: 10px 12px; overflow: auto; position: relative; }
    .tab-content {
      display: none;
    }
    .tab-content.active {
      display: grid;
      gap: 10px;
    }
    #meta-body .row { display:grid; grid-template-columns: 1fr; gap: 6px; }
    #meta-body label { font-size: 12px; color: #333; }
    #meta-body textarea { width: 100%; min-height: 100px; max-height: 45vh; padding: 8px; resize: vertical; border: 1px solid var(--line); border-radius: 8px; font: 13px/1.45 ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; }
    #meta-body input[type="password"], #meta-body input[type="number"], #meta-body select { width: 100%; padding: 8px; border: 1px solid var(--line); border-radius: 8px; font: 13px/1.45 system-ui, -apple-system, Segoe UI, Roboto, sans-serif; }
    #meta-body input[type="range"] { width: 100%; }
    #meta-body input[type="password"] { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; }
    #meta-body button { padding: 10px 12px; border: 1px solid var(--line); background: #fff; border-radius: 8px; cursor: pointer; font: 13px/1.45 system-ui, -apple-system, Segoe UI, Roboto, sans-serif; font-weight: 600; }
    #meta-body button:hover:not(:disabled) { background: var(--muted); }
    #meta-body button:disabled { opacity: 0.5; cursor: not-allowed; }
    #meta-body button.generating { background: #f0f8ff; border-color: #4a90e2; }
    #next-enable-wrap { display:flex; align-items:center; justify-content:flex-end; gap: 8px; }
    .range-value { font-size: 12px; color: #666; margin-left: 8px; }

    /* Panel footer */
    #meta-foot { padding: 8px 12px; border-top: 1px solid var(--line); font-size:12px; color: var(--sub); display:flex; justify-content: space-between; align-items:center; gap: 8px; }

    /* Scrim behind drawer */
    #meta-scrim {
      position: fixed; inset: 0; background: rgba(0,0,0,0.18);
      opacity: 0; pointer-events: none; transition: opacity 200ms ease; z-index: 40;
    }
    #meta-scrim[data-open="1"] { opacity: 1; pointer-events: auto; }

    /* Side tab button */
    #meta-tab {
      position: fixed; right: 0; top: 50%; transform: translate(50%, -50%);
      writing-mode: vertical-rl; text-orientation: mixed;
      background: #fff; border: 1px solid var(--line); border-right: none; border-radius: 10px 0 0 10px;
      padding: 10px 8px; font-size: 12px; cursor: pointer; z-index: 60;
      box-shadow: -4px 4px 12px rgba(0,0,0,0.06);
    }
    #meta-tab[aria-disabled="true"] { opacity: 0.5; cursor: not-allowed; }

    /* Responsive niceties */
    @media (max-width: 480px) {
      :root { --meta-w: 92vw; }
      #meta-tab { top: auto; bottom: 18px; transform: translate(50%, 0); writing-mode: horizontal-tb; }
    }

    /* Fixed Generate Button */
    #fixed-generate-btn {
      position: fixed;
      bottom: 20px;
      right: 20px;
      padding: 12px 24px;
      background: #4a90e2;
      color: white;
      border: none;
      border-radius: 12px;
      font: 14px/1.4 system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      font-weight: 600;
      cursor: pointer;
      box-shadow: 0 4px 12px rgba(74, 144, 226, 0.3);
      transition: all 200ms ease;
      z-index: 100;
      display: none;
    }
    #fixed-generate-btn:hover:not(:disabled) {
      background: #357abd;
      transform: translateY(-1px);
      box-shadow: 0 6px 16px rgba(74, 144, 226, 0.4);
    }
    #fixed-generate-btn:disabled {
      background: #ccc;
      cursor: not-allowed;
      transform: none;
      box-shadow: 0 2px 6px rgba(0,0,0,0.1);
    }
    #fixed-generate-btn.generating {
      background: #f0c14b;
      color: #333;
    }
    #fixed-generate-btn.visible {
      display: block;
    }

    /* Cancel button */
    #cancel-generate-btn {
      position: fixed;
      bottom: 20px;
      right: 180px;
      padding: 8px 16px;
      background: #dc3545;
      color: white;
      border: none;
      border-radius: 8px;
      font: 12px/1.4 system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      font-weight: 600;
      cursor: pointer;
      box-shadow: 0 2px 8px rgba(220, 53, 69, 0.3);
      transition: all 200ms ease;
      z-index: 100;
      display: none;
    }
    #cancel-generate-btn:hover {
      background: #c82333;
      transform: translateY(-1px);
    }
    #cancel-generate-btn.visible {
      display: block;
    }
  </style>
</head>
<body data-mode="edit">
<div class="app">
  <header>
    <div class="toolbar">
      <div class="row">
        <button id="auth-btn">Sign in</button>
        <button id="signout-btn" disabled>Sign out</button>
        <span class="pill" id="auth-state">Signed out</span>
      </div>
      <div class="row">
        <button id="create-file-btn" disabled>Create new file</button>
        <input id="file-id-input" type="text" placeholder="Paste File ID and press Enter (or use ?file=...)" />
        <button id="list-btn" disabled>My files</button>
      </div>
      <div class="row" id="formatting-row" title="Formatting inserts Markdown/HTML into the plaintext">
        <button id="bold-btn" aria-label="Bold (Ctrl/⌘+B)"><strong>B</strong></button>
        <button id="italic-btn" aria-label="Italic (Ctrl/⌘+I)"><em>I</em></button>
        <button id="underline-btn" aria-label="Underline (Ctrl/⌘+U)"><u>U</u></button>
        <button id="hidden-btn" aria-label="Hidden text (Ctrl/⌘+H)">[H]</button>
        <button id="bullet-btn" aria-label="Bulleted list (Ctrl/⌘+Shift+8)">• List</button>
        <button id="header-btn" aria-label="Add header to selection" class="pill" style="background:#fff;border:1px solid var(--line)">Hdr</button>
        <select id="heading-select" aria-label="Heading">
          <option value="0">Paragraph</option>
          <option value="1">H1</option>
          <option value="2">H2</option>
          <option value="3">H3</option>
          <option value="4">H4</option>
          <option value="5">H5</option>
          <option value="6">H6</option>
        </select>
        <button id="toggle-preview">Preview</button>
        <button id="toggle-split">Split</button>
      </div>
    </div>
    <div id="list-panel">
      <table>
        <thead><tr><th style="width:45%">Name</th><th style="width:35%">Modified</th><th style="width:20%">Actions</th></tr></thead>
        <tbody id="list-body"></tbody>
      </table>
    </div>
  </header>

  <main class="main">
    <div id="editor-wrap">
      <textarea id="editor" placeholder="Write your story here…"></textarea>
    </div>
    <div id="preview" aria-live="polite"></div>
  </main>

  <footer>
    <span id="status">Ready.</span>
    <span id="active-file"></span>
    <span class="dot idle" id="save-indicator" title="Save status"></span>
    <span class="pill" id="sync-note"></span>
  </footer>
</div>

<!-- Side tab and drawer -->
<button id="meta-tab" aria-expanded="false" aria-controls="meta-panel" title="Metadata (Alt+M)">Metadata</button>
<div id="meta-scrim" aria-hidden="true"></div>

<!-- Fixed Generate Button -->
<button id="fixed-generate-btn" title="Generate AI content (Ctrl/⌘+G)">Generate with AI</button>
<button id="cancel-generate-btn" title="Cancel generation">Cancel</button>
<aside id="meta-panel" role="complementary" aria-label="Story metadata" data-open="0">
  <div id="meta-head">
    <div id="meta-title">Settings</div>
    <div style="display:flex; gap:6px; align-items:center;">
      <button id="meta-save-now" title="Save now (Ctrl/⌘+S)">Save</button>
      <button id="meta-close" title="Close (Esc)">Close</button>
    </div>
  </div>
  
  <!-- Tab Navigation -->
  <div id="meta-tabs">
    <button class="meta-tab-btn active" data-tab="story">Story Settings</button>
    <button class="meta-tab-btn" data-tab="ai">AI Settings</button>
    <button class="meta-tab-btn" data-tab="display">Display</button>
  </div>
  
  <div id="meta-body">
    <!-- Story Settings Tab -->
    <div id="story-tab" class="tab-content active">
      <div class="row">
        <label for="ai-pre">AI Pre‑prompt</label>
        <textarea id="ai-pre" placeholder="System-style guidance for the model…"></textarea>
      </div>
      <div class="row">
        <label for="next-inst">Next Instructions</label>
        <textarea id="next-inst" placeholder="Steering for the next generation…"></textarea>
        <div id="next-enable-wrap">
          <label style="display:flex;align-items:center;gap:6px;"><input type="checkbox" id="next-enabled" /> Enable</label>
        </div>
      </div>
    </div>
    
    <!-- AI Settings Tab -->
    <div id="ai-tab" class="tab-content">
      <div class="row">
        <label for="openrouter-key">OpenRouter API Key</label>
        <input type="password" id="openrouter-key" placeholder="sk-or-v1-..." title="Get your API key from https://openrouter.ai/" />
        <div style="display:flex;align-items:center;gap:6px;margin-top:4px;">
          <label style="display:flex;align-items:center;gap:6px;"><input type="checkbox" id="remember-key" /> Remember API key</label>
        </div>
      </div>
      <div class="row">
        <label for="ai-model">AI Model</label>
        <div style="position: relative;">
          <input type="text" id="ai-model" placeholder="Search for a model..." title="Search and select AI model" />
          <div id="model-dropdown" style="display: none; position: absolute; top: 100%; left: 0; right: 0; background: white; border: 1px solid var(--line); border-top: none; border-radius: 0 0 8px 8px; max-height: 200px; overflow-y: auto; z-index: 1000;"></div>
        </div>
      </div>
      <div class="row">
        <label for="max-tokens">Max Output Tokens</label>
        <input type="number" id="max-tokens" min="1" max="4000" value="1000" />
      </div>
      <div class="row">
        <label for="temperature">Temperature</label>
        <input type="range" id="temperature" min="0" max="2" step="0.1" value="0.7" />
        <span class="range-value">0.7</span>
      </div>
      <div class="row">
        <label for="top-p">Top P</label>
        <input type="range" id="top-p" min="0" max="1" step="0.05" value="1" />
        <span class="range-value">1.0</span>
      </div>
      <div class="row">
        <label for="top-k">Top K</label>
        <input type="number" id="top-k" min="1" max="100" value="0" placeholder="0 = disabled" />
      </div>
      <div class="row">
        <label>Estimated Cost</label>
        <div id="cost-estimate" class="pill" style="background:#e8f4fd;border:1px solid #bee5eb;">~$0.00 per generation</div>
      </div>
      <div class="row" style="margin-top:20px;padding-top:20px;border-top:1px solid var(--line);">
        <div style="font-size:12px;color:#666;text-align:center;">
          Use the blue "Generate with AI" button at the bottom-right corner to generate content.
        </div>
      </div>
    </div>
    
    <!-- Display Settings Tab -->
    <div id="display-tab" class="tab-content">
      <div class="row">
        <label>Theme</label>
        <select id="theme-select">
          <option value="light">Light</option>
          <option value="dark" disabled>Dark (Coming Soon)</option>
        </select>
      </div>
      <div class="row">
        <label>Editor Font Size</label>
        <input type="range" id="font-size" min="12" max="18" step="1" value="14" />
        <span class="range-value">14px</span>
      </div>
    </div>
  </div>
  <div id="meta-foot">
    <div>Changes autosave with content. <span class="pill">Alt+M</span> toggles. <span class="pill">Ctrl/⌘+G</span> generates AI.</div>
    <div id="meta-hint" class="pill" style="background:#fff;border:1px solid var(--line)">Drive‑synced</div>
  </div>
</aside>

<script>
  // =========================
  //  Configuration
  // =========================
  const CLIENT_ID = "389780383024-03s13biqo3n1hvdv2mn8jb2fcvc17ks3.apps.googleusercontent.com"; // OAuth 2.0 Web client ID (public)
  const SCOPE = "https://www.googleapis.com/auth/drive.file https://www.googleapis.com/auth/drive.appdata"; // Drive scope + app data

  const DRIVE_UPLOAD_URL = "https://www.googleapis.com/upload/drive/v3/files";
  const DRIVE_FILES_URL  = "https://www.googleapis.com/drive/v3/files";
  
  // AI Settings
  const AI_SETTINGS_FILENAME = "ghostwriter-ai-settings.json";

  // Autosave + polling
  const AUTOSAVE_DELAY = 1200;  // ms after last keystroke
  const POLL_INTERVAL  = 8000;  // ms between remote checks
  const IDLE_GRACE     = 1200;  // ms considered "still typing"

  // File format sentinels for JSON header
  const META_START = ";;;GW:JSON-START";
  const META_END   = ";;;GW:JSON-END";

  const DEFAULT_META = {
    ai_pre_prompt: "",
    next_instructions: "",
    next_instructions_enabled: false,
    openrouter_key: "",
    remember_key: false,
    ai_model: "",
    max_tokens: 1000,
    temperature: 0.7,
    top_p: 1.0,
    top_k: 0
  };

  // =========================
  //  DOM
  // =========================
  const authBtn      = document.getElementById("auth-btn");
  const signoutBtn   = document.getElementById("signout-btn");
  const createBtn    = document.getElementById("create-file-btn");
  const listBtn      = document.getElementById("list-btn");
  const fileIdInput  = document.getElementById("file-id-input");
  const editor       = document.getElementById("editor");
  const statusEl     = document.getElementById("status");
  const authStateEl  = document.getElementById("auth-state");
  const activeFileEl = document.getElementById("active-file");
  const listPanel    = document.getElementById("list-panel");
  const listBody     = document.getElementById("list-body");
  const saveDot      = document.getElementById("save-indicator");
  const syncNote     = document.getElementById("sync-note");
  const boldBtn      = document.getElementById("bold-btn");
  const italicBtn    = document.getElementById("italic-btn");
  const underlineBtn = document.getElementById("underline-btn");
  const hiddenBtn    = document.getElementById("hidden-btn");
  const bulletBtn    = document.getElementById("bullet-btn");
  const headerBtn    = document.getElementById("header-btn");
  const headingSel   = document.getElementById("heading-select");
  const togglePreviewBtn = document.getElementById("toggle-preview");
  const toggleSplitBtn   = document.getElementById("toggle-split");
  const previewEl    = document.getElementById("preview");

  // Side panel elements
  const metaPanel    = document.getElementById("meta-panel");
  const metaScrim    = document.getElementById("meta-scrim");
  const metaTab      = document.getElementById("meta-tab");
  const metaClose    = document.getElementById("meta-close");
  const metaSaveNow  = document.getElementById("meta-save-now");

  const aiPreInput   = document.getElementById("ai-pre");
  const nextInstInput= document.getElementById("next-inst");
  const nextEnabled  = document.getElementById("next-enabled");
  const openrouterKey = document.getElementById("openrouter-key");
  const rememberKey  = document.getElementById("remember-key");
  const aiModel      = document.getElementById("ai-model");
  const modelDropdown = document.getElementById("model-dropdown");

  const fixedGenerateBtn = document.getElementById("fixed-generate-btn");
  const cancelGenerateBtn = document.getElementById("cancel-generate-btn");
  const maxTokensInput = document.getElementById("max-tokens");
  const temperatureInput = document.getElementById("temperature");
  const topPInput = document.getElementById("top-p");
  const topKInput = document.getElementById("top-k");
  const costEstimate = document.getElementById("cost-estimate");

  // =========================
  //  Auth & state
  // =========================
  let tokenClient = null;
  let accessToken = null; // kept in-memory only
  let currentFileId = null;
  let currentFileName = null;
  let autosaveTimer = null;
  let pollTimer = null;
  let isSaving = false;
  let dirty = false;           // local edits (editor or metadata) since last save
  let lastInputTs = 0;         // timestamp of last edit
  let lastRemoteModified = 0;  // ms
  
  // AI Settings state
  let aiSettingsFileId = null; // ID of the AI settings file in appdata folder
  let aiSettingsLoaded = false; // whether we've attempted to load AI settings
  let saveAISettingsTimer = null; // timer for delayed AI settings save
  
  // Generation state
  let isGenerating = false;
  let generationController = null; // AbortController for canceling requests
  
  // Current active tab
  let activeTab = 'story';
  
  // Available models from OpenRouter
  let availableModels = [
    // Default models to show even without API key
    { id: 'anthropic/claude-3.5-sonnet', name: 'Claude 3.5 Sonnet', pricing: 0.000015, displayText: 'anthropic/claude-3.5-sonnet - $0.000015/1K tokens' },
    { id: 'anthropic/claude-3-haiku', name: 'Claude 3 Haiku', pricing: 0.00000025, displayText: 'anthropic/claude-3-haiku - $0.000000/1K tokens' },
    { id: 'openai/gpt-4o', name: 'GPT-4o', pricing: 0.00001, displayText: 'openai/gpt-4o - $0.000010/1K tokens' },
    { id: 'openai/gpt-4o-mini', name: 'GPT-4o Mini', pricing: 0.00000015, displayText: 'openai/gpt-4o-mini - $0.000000/1K tokens' },
    { id: 'meta-llama/llama-3.1-70b-instruct', name: 'Llama 3.1 70B', pricing: 0.0000009, displayText: 'meta-llama/llama-3.1-70b-instruct - $0.000001/1K tokens' },
    { id: 'meta-llama/llama-3.1-8b-instruct', name: 'Llama 3.1 8B', pricing: 0.00000006, displayText: 'meta-llama/llama-3.1-8b-instruct - $0.000000/1K tokens' }
  ];

  function setStatus(msg) { statusEl.textContent = msg; }
  function setSaveDot(state) {
    saveDot.classList.remove("saving","saved","idle");
    saveDot.classList.add(state);
  }
  function setActiveFile(id, name) {
    currentFileId = id || null;
    currentFileName = name || null;
    fileIdInput.value = id || "";
    activeFileEl.textContent = id ? `• File: ${name || "(untitled)"} — ID: ${id}` : "";
  }
  function setSignedInUI(signedIn) {
    authStateEl.textContent = signedIn ? "Signed in" : "Signed out";
    createBtn.disabled = !signedIn;
    signoutBtn.disabled = !signedIn;
    listBtn.disabled = !signedIn;
    fileIdInput.disabled = !signedIn;
    [boldBtn, italicBtn, underlineBtn, hiddenBtn, bulletBtn, headerBtn, headingSel, togglePreviewBtn, toggleSplitBtn, aiPreInput, nextInstInput, nextEnabled, metaClose, metaSaveNow, fixedGenerateBtn].forEach(el => el.disabled = !signedIn);
    metaTab.setAttribute('aria-disabled', String(!signedIn));
    if (!signedIn) openMeta(false);
  }
  function getQueryFileId() { const p = new URLSearchParams(location.search); return p.get("file"); }

  window.addEventListener("load", () => {
    const waitFor = (cond) => new Promise(res => { const t = () => cond() ? res() : setTimeout(t, 50); t(); });
    waitFor(() => window.google && google.accounts && google.accounts.oauth2).then(() => {
      tokenClient = google.accounts.oauth2.initTokenClient({
        client_id: CLIENT_ID,
        scope: SCOPE,
        callback: (resp) => {
          if (resp.error) { console.error(resp); setStatus("Auth error."); return; }
          accessToken = resp.access_token;
          setCookie('ghostwriter_auth', accessToken, 1); // Save for 1 day
          setStatus("Signed in.");
          setSignedInUI(true);
          loadAISettings(); // Load saved AI settings after authentication
          const preset = getQueryFileId();
          if (preset) { fileIdInput.value = preset; loadFile(preset); }
        }
      });
      wireEvents();
      
      // Check for saved authentication
      const savedAuth = getCookie('ghostwriter_auth');
      if (savedAuth) {
        accessToken = savedAuth;
        setStatus("Restoring session...");
        setSignedInUI(true);
        loadAISettings();
        const preset = getQueryFileId();
        if (preset) { fileIdInput.value = preset; loadFile(preset); }
      } else {
        setStatus("Ready. Sign in to begin.");
      }
      
      updateGenerateButton(); // Initialize AI button state
    }).catch(err => { console.error(err); setStatus("Failed to initialize Google Identity Services."); });
  });

  function ensureAuth(action, fn) {
    return () => {
      if (!accessToken) {
        setStatus(`Requesting permission for ${action}…`);
        tokenClient.requestAccessToken({ prompt: "consent" });
        return;
      }
      fn();
    };
  }

  // Cookie management for auth persistence
  function setCookie(name, value, days = 30) {
    const expires = new Date();
    expires.setTime(expires.getTime() + (days * 24 * 60 * 60 * 1000));
    document.cookie = `${name}=${value};expires=${expires.toUTCString()};path=/;SameSite=Lax`;
  }

  function getCookie(name) {
    const nameEQ = name + "=";
    const ca = document.cookie.split(';');
    for (let i = 0; i < ca.length; i++) {
      let c = ca[i];
      while (c.charAt(0) === ' ') c = c.substring(1, c.length);
      if (c.indexOf(nameEQ) === 0) return c.substring(nameEQ.length, c.length);
    }
    return null;
  }

  function deleteCookie(name) {
    document.cookie = `${name}=;expires=Thu, 01 Jan 1970 00:00:01 GMT;path=/`;
  }

  function wireEvents() {
    document.getElementById("auth-btn").addEventListener("click", () => { setStatus("Opening Google sign-in…"); tokenClient.requestAccessToken({ prompt: "consent" }); });
    signoutBtn.addEventListener("click", () => {
      if (accessToken) {
        stopPolling();
        // Clear AI settings state on signout
        aiSettingsLoaded = false;
        aiSettingsFileId = null;
        if (!rememberKey.checked) {
          openrouterKey.value = "";
        }
        updateGenerateButton();
        deleteCookie('ghostwriter_auth'); // Clear saved auth
        google.accounts.oauth2.revoke(accessToken, () => { accessToken = null; setSignedInUI(false); setActiveFile(null, null); setStatus("Signed out."); });
      }
    });

    createBtn.addEventListener("click", ensureAuth("creating a file", createNewFile));

    fileIdInput.addEventListener("keydown", (e) => { if (e.key === "Enter") { const id = fileIdInput.value.trim(); if (id) ensureAuth("opening a file", () => loadFile(id))(); } });

    listBtn.addEventListener("click", ensureAuth("listing files", async () => { listPanel.style.display = listPanel.style.display === "none" ? "block" : "none"; if (listPanel.style.display === "block") { await refreshList(); } }));

    // Editor typing => autosave & preview
    editor.addEventListener("input", () => { markDirty(); updatePreview(); });

    // Metadata edits => autosave
    aiPreInput.addEventListener("input", () => { markDirty(); });
    nextInstInput.addEventListener("input", () => { markDirty(); });
    nextEnabled.addEventListener("change", () => { markDirty(); });
    openrouterKey.addEventListener("input", () => { 
      markDirty(); 
      updateGenerateButton(); 
      // Save API key after user stops typing (only if remember is checked)
      if (rememberKey.checked) {
        clearTimeout(saveAISettingsTimer);
        saveAISettingsTimer = setTimeout(() => saveAISettings(), 2000);
      }
    });
    rememberKey.addEventListener("change", () => { markDirty(); saveAISettings(); });
    
    // AI Model search functionality
    aiModel.addEventListener("input", () => { 
      filterModels(aiModel.value); 
    });
    aiModel.addEventListener("focus", () => {
      if (aiModel.value.trim()) {
        filterModels(aiModel.value);
      }
    });
    aiModel.addEventListener("blur", () => {
      // Hide dropdown after a delay to allow clicking on items
      setTimeout(() => {
        modelDropdown.style.display = 'none';
      }, 200);
    });
    aiModel.addEventListener("change", () => { markDirty(); updateGenerateButton(); saveAISettings(); });

    // Drawer open/close
    const toggle = () => openMeta(metaPanel.getAttribute('data-open') !== '1');
    metaTab.addEventListener('click', () => { if (metaTab.getAttribute('aria-disabled') === 'true') return; toggle(); });
    metaScrim.addEventListener('click', () => openMeta(false));
    metaClose.addEventListener('click', () => openMeta(false));

    // Keyboard shortcuts
    window.addEventListener("keydown", (e) => {
      const isMac = navigator.platform.toLowerCase().includes("mac");
      const primary = isMac ? e.metaKey : e.ctrlKey;
      if (primary && e.key.toLowerCase() === "s") { e.preventDefault(); flushSave(); return; }
      if (primary && e.key.toLowerCase() === "b") { e.preventDefault(); toggleBold(); return; }
      if (primary && e.key.toLowerCase() === "i") { e.preventDefault(); toggleItalic(); return; }
      if (primary && e.key.toLowerCase() === "u") { e.preventDefault(); toggleUnderline(); return; }
      if (primary && e.key.toLowerCase() === "h") { e.preventDefault(); toggleHidden(); return; }
      if (primary && e.shiftKey && e.key === "8") { e.preventDefault(); toggleBulleted(); return; }
      if (primary && /^[1-6]$/.test(e.key)) { e.preventDefault(); toggleHeading(parseInt(e.key,10)); headingSel.value = e.key; return; }
      // Alt+M toggles metadata drawer
      if ((e.altKey || e.metaKey && e.shiftKey) && e.key.toLowerCase() === 'm') { e.preventDefault(); const wantOpen = metaPanel.getAttribute('data-open') !== '1'; openMeta(wantOpen); return; }
      // Ctrl/Cmd+G generates AI content (if AI panel is open and configured)
      if (primary && e.key.toLowerCase() === 'g') { 
        if (metaPanel.getAttribute('data-open') === '1' && !fixedGenerateBtn.disabled) {
          e.preventDefault(); 
          generateAIContent(); 
        }
        return; 
      }
      if (e.key === 'Escape') { if (metaPanel.getAttribute('data-open') === '1') { e.preventDefault(); openMeta(false); } }
      if (e.key === "Tab") {
        const { start, end } = getSelection(editor);
        const lines = getSelectedLineRange(editor.value, start, end);
        if (lines.text.match(/^(\-\s|\s*)/m)) { e.preventDefault(); if (e.shiftKey) outdentSelection(); else indentSelection(); }
      }
    });

    // Formatting toolbar
    document.getElementById("bold-btn").addEventListener("click", () => { toggleBold(); updatePreview(); });
    document.getElementById("italic-btn").addEventListener("click", () => { toggleItalic(); updatePreview(); });
    document.getElementById("underline-btn").addEventListener("click", () => { toggleUnderline(); updatePreview(); });
    document.getElementById("hidden-btn").addEventListener("click", () => { toggleHidden(); updatePreview(); });
    document.getElementById("bullet-btn").addEventListener("click", () => { toggleBulleted(); updatePreview(); });
    document.getElementById("header-btn").addEventListener("click", () => { toggleHeading(1); headingSel.value = "1"; updatePreview(); });
    headingSel.addEventListener("change", () => { const lvl = parseInt(headingSel.value, 10); if (!isNaN(lvl)) { toggleHeading(lvl); updatePreview(); } });

    // Preview mode toggles - with retry to ensure DOM is ready
    function bindPreviewEvents() {
      const previewBtn = document.getElementById("toggle-preview");
      const splitBtn = document.getElementById("toggle-split");
      
      if (previewBtn && splitBtn) {
        previewBtn.addEventListener("click", () => { 
          const mode = document.body.getAttribute("data-mode"); 
          document.body.setAttribute("data-mode", mode === "preview" ? "edit" : "preview"); 
          updatePreview(); 
        });
        splitBtn.addEventListener("click", () => { 
          const mode = document.body.getAttribute("data-mode"); 
          document.body.setAttribute("data-mode", mode === "split" ? "edit" : "split"); 
          updatePreview(); 
        });
      } else {
        // Retry after a delay if buttons not found
        setTimeout(bindPreviewEvents, 100);
      }
    }
    bindPreviewEvents();

    // Save button in drawer
    metaSaveNow.addEventListener('click', () => flushSave());



    // Tab switching - with retry to ensure DOM is ready
    function bindTabEvents() {
      const tabBtns = document.querySelectorAll('.meta-tab-btn');
      if (tabBtns.length > 0) {
        tabBtns.forEach(btn => {
          btn.addEventListener('click', () => switchTab(btn.dataset.tab));
        });
      } else {
        // Retry after a short delay if buttons not found
        setTimeout(bindTabEvents, 100);
      }
    }
    bindTabEvents();

    // Fixed generate button
    fixedGenerateBtn.addEventListener('click', () => generateAIContent());
    cancelGenerateBtn.addEventListener('click', () => cancelGeneration());

    // Range input updates
    temperatureInput.addEventListener('input', () => {
      temperatureInput.nextElementSibling.textContent = temperatureInput.value;
      updateCostEstimate();
      markDirty();
    });
    topPInput.addEventListener('input', () => {
      topPInput.nextElementSibling.textContent = topPInput.value;
      updateCostEstimate();
      markDirty();
    });
    
    // Other AI settings changes
    maxTokensInput.addEventListener('input', () => { updateCostEstimate(); markDirty(); });
    topKInput.addEventListener('input', () => { updateCostEstimate(); markDirty(); });
    
    // Auto-refresh models when API key changes
    openrouterKey.addEventListener('input', () => { 
      markDirty(); 
      // Auto-fetch models if key looks valid (longer than 10 chars)
      if (openrouterKey.value.trim().length > 10) {
        refreshAvailableModels();
      }
    });

    window.addEventListener("visibilitychange", () => { if (document.visibilityState === "hidden") flushSave({ silent:true }); });
    window.addEventListener("beforeunload", () => { flushSave({ silent:true }); });
  }

  // Drawer controller
  function openMeta(open) {
    metaPanel.setAttribute('data-open', open ? '1' : '0');
    metaScrim.setAttribute('data-open', open ? '1' : '0');
    metaTab.setAttribute('aria-expanded', String(open));
    if (open) {
      // Focus the first editable input for speedy tweaking
      setTimeout(() => { aiPreInput.focus(); aiPreInput.setSelectionRange(aiPreInput.value.length, aiPreInput.value.length); }, 80);
    } else {
      metaTab.focus();
    }
  }

  // Tab switching
  function switchTab(tabName) {
    // Hide all tab contents
    document.querySelectorAll('.tab-content').forEach(tab => tab.classList.remove('active'));
    document.querySelectorAll('.meta-tab-btn').forEach(btn => btn.classList.remove('active'));
    
    // Show selected tab
    document.getElementById(tabName + '-tab').classList.add('active');
    document.querySelector(`[data-tab="${tabName}"]`).classList.add('active');
    
    activeTab = tabName;
  }

  // =========================
  //  JSON header <-> UI
  // =========================
  function readMetaFromUI(){
    return {
      ai_pre_prompt: aiPreInput.value || "",
      next_instructions: nextInstInput.value || "",
      next_instructions_enabled: !!nextEnabled.checked,
      openrouter_key: rememberKey.checked ? (openrouterKey.value || "") : "",
      remember_key: !!rememberKey.checked,
      ai_model: aiModel.value || "",
      max_tokens: parseInt(maxTokensInput.value) || 1000,
      temperature: parseFloat(temperatureInput.value) || 0.7,
      top_p: parseFloat(topPInput.value) || 1.0,
      top_k: parseInt(topKInput.value) || 0
    };
  }
  function writeMetaToUI(meta){
    aiPreInput.value = meta.ai_pre_prompt || "";
    nextInstInput.value = meta.next_instructions || "";
    nextEnabled.checked = !!meta.next_instructions_enabled;
    openrouterKey.value = meta.openrouter_key || "";
    rememberKey.checked = !!meta.remember_key;
    aiModel.value = meta.ai_model || "";
    maxTokensInput.value = meta.max_tokens || 1000;
    temperatureInput.value = meta.temperature || 0.7;
    topPInput.value = meta.top_p || 1.0;
    topKInput.value = meta.top_k || 0;
    
    // Update range displays
    temperatureInput.nextElementSibling.textContent = temperatureInput.value;
    topPInput.nextElementSibling.textContent = topPInput.value;
    
    updateGenerateButton();
  }

  function buildFileText(meta, content){
    const json = JSON.stringify(meta, null, 2);
    return `${META_START}\n${json}\n${META_END}\n\n${content || ""}`;
  }
  function parseFileText(text){
    try {
      const s = text.indexOf(META_START);
      const e = text.indexOf(META_END);
      if (s !== -1 && e !== -1 && e > s){
        const jsonStr = text.slice(s + META_START.length, e).trim();
        const meta = JSON.parse(jsonStr);
        const after = text.slice(e + META_END.length).replace(/^\s*\n?/, "");
        return { meta: { ...DEFAULT_META, ...meta }, content: after };
      }
    } catch (err) { console.warn("Meta parse error; treating entire file as content.", err); }
    return { meta: { ...DEFAULT_META }, content: text };
  }

  // =========================
  //  Formatting helpers (Markdown-in-plaintext)
  // =========================
  function getSelection(el){ return { start: el.selectionStart, end: el.selectionEnd, value: el.value }; }
  function setSelection(el, start, end){ el.setSelectionRange(start, end); }
  function markDirty(){ dirty = true; lastInputTs = Date.now(); setSaveDot("saving"); scheduleAutosave(); }
  function applyChange(newValue, selStart, selEnd){ editor.value = newValue; setSelection(editor, selStart, selEnd); markDirty(); }

  function wrapOrUnwrapSelection(markerL, markerR, { altL = [], altR = [] } = {}){
    const { start, end, value } = getSelection(editor);
    const sel = value.slice(start, end); const before = value.slice(0, start); const after = value.slice(end);
    const allL = [markerL, ...altL]; const allR = [markerR, ...altR];
    const isWrapped = allL.some((L,i) => sel.startsWith(L) && sel.endsWith(allR[i] || markerR));
    if (isWrapped) {
      let unwrapped = sel;
      allL.forEach((L,i)=>{ const R = allR[i] || markerR; if (unwrapped.startsWith(L) && unwrapped.endsWith(R)) { unwrapped = unwrapped.slice(L.length, unwrapped.length - R.length); } });
      applyChange(before + unwrapped + after, start, start + unwrapped.length);
    } else {
      const insertL = markerL; const insertR = markerR;
      if (start === end) { const nv = before + insertL + insertR + after; const caret = (before + insertL).length; applyChange(nv, caret, caret); }
      else { const nv = before + insertL + sel + insertR + after; applyChange(nv, start + insertL.length, start + insertL.length + sel.length); }
    }
  }
  function toggleBold(){ wrapOrUnwrapSelection("**", "**", { altL:["__"], altR:["__"] }); }
  function toggleItalic(){ wrapOrUnwrapSelection("*", "*", { altL:["_"], altR:["_"] }); }
  function toggleUnderline(){ wrapOrUnwrapSelection("<u>", "</u>"); }
  function toggleHidden(){ wrapOrUnwrapSelection("[", "]"); }

  function getSelectedLineRange(text, start, end){ const lineStart = text.lastIndexOf("\n", start - 1) + 1; let lineEnd = text.indexOf("\n", end); if (lineEnd === -1) lineEnd = text.length; return { start: lineStart, end: lineEnd, text: text.slice(lineStart, lineEnd) }; }
  function toggleBulleted(){ const { start, end, value } = getSelection(editor); const range = getSelectedLineRange(value, start, end); const lines = value.slice(range.start, range.end).split("\n"); const allBulleted = lines.every(l => /^\s*-\s/.test(l) || l.trim() === ""); const changed = lines.map(l => { if (l.trim() === "") return l; if (allBulleted) return l.replace(/^\s*-\s?/, ""); return l.replace(/^\s*/, "$&- "); }).join("\n"); const nv = value.slice(0, range.start) + changed + value.slice(range.end); const delta = changed.length - (range.end - range.start); applyChange(nv, start + (start - range.start), end + delta - (range.end - end)); }
  function toggleHeading(level){ const { start, end, value } = getSelection(editor); const range = getSelectedLineRange(value, start, end); const lines = range.text.split("\n"); const prefix = "#".repeat(Math.min(Math.max(level,0),6)); const changed = lines.map(l => { if (l.trim() === "") return l; const cur = l.match(/^\s*(#{1,6})\s+/); if (level === 0) { return cur ? l.replace(/^\s*#{1,6}\s+/, "") : l; } if (cur && cur[1].length === level) { return l.replace(/^\s*#{1,6}\s+/, ""); } return l.replace(/^\s*(#{1,6}\s+)?/, prefix + " "); }).join("\n"); const nv = value.slice(0, range.start) + changed + value.slice(range.end); const delta = changed.length - (range.end - range.start); applyChange(nv, start, end + delta); }
  function indentSelection(){ const { start, end, value } = getSelection(editor); const range = getSelectedLineRange(value, start, end); const lines = range.text.split("\n"); const changed = lines.map(l => l.trim() === "" ? l : "  " + l).join("\n"); const nv = value.slice(0, range.start) + changed + value.slice(range.end); const delta = changed.length - (range.end - range.start); applyChange(nv, start + 2, end + delta + 2); }
  function outdentSelection(){ const { start, end, value } = getSelection(editor); const range = getSelectedLineRange(value, start, end); const lines = range.text.split("\n"); const changed = lines.map(l => l.replace(/^ {1,2}/, "")).join("\n"); const nv = value.slice(0, range.start) + changed + value.slice(range.end); const delta = changed.length - (range.end - range.start); applyChange(nv, Math.max(range.start, start - 2), Math.max(range.start, end + delta - 2)); }

  // =========================
  //  Markdown renderer (safe-ish)
  // =========================
  function escapeHtml(str){ return String(str).replaceAll('&','&amp;').replaceAll('<','&lt;').replaceAll('>','&gt;'); }
  function applyInline(md){ let s = escapeHtml(md); s = s.replace(/\[([^\]]*)\]/g, ''); s = s.replace(/\*\*([^\n*]+)\*\*/g, '<strong>$1</strong>'); s = s.replace(/(^|[^*])\*([^\n*]+)\*(?!\*)/g, '$1<em>$2</em>'); s = s.replace(/&lt;u&gt;([\s\S]*?)&lt;\/u&gt;/g, '<u>$1</u>'); return s; }
  function renderMarkdown(md){ 
    const lines = md.replace(/\r\n/g,'\n').split('\n'); 
    let html = ''; 
    let inList = false; 
    const flushList = () => { if (inList) { html += '</ul>'; inList = false; } }; 
    
    // Process lines and handle multiple empty lines
    for (let i = 0; i < lines.length; i++) { 
      const line = lines[i]; 
      
      // Check for headers
      const h = line.match(/^(#{1,6})\s+(.*)$/); 
      if (h){ 
        flushList(); 
        const lvl = h[1].length; 
        const text = h[2]; 
        html += `<h${lvl}>${applyInline(text)}</h${lvl}>`; 
        continue; 
      } 
      
      // Check for bulleted lists
      const b = line.match(/^\s*-\s+(.*)$/); 
      if (b){ 
        if (!inList){ html += '<ul>'; inList = true; } 
        html += `<li>${applyInline(b[1])}</li>`; 
        continue; 
      } 
      
      // Handle empty lines - look ahead for multiple consecutive empty lines
      if (/^\s*$/.test(line)) { 
        flushList(); 
        
        // Count consecutive empty lines
        let emptyCount = 1;
        let j = i + 1;
        while (j < lines.length && /^\s*$/.test(lines[j])) {
          emptyCount++;
          j++;
        }
        
        if (emptyCount >= 3) {
          // 3+ empty lines = 1.5x spacing
          html += '<div style="margin-bottom: 0.75em;"></div>'; 
        } else if (emptyCount === 2) {
          // 2 empty lines = 1.5x spacing
          html += '<div style="margin-bottom: 0.75em;"></div>'; 
        } else {
          // Single empty line = normal break
          html += '<br />'; 
        }
        
        // Skip the counted empty lines
        i = j - 1;
        continue; 
      } 
      
      // Regular paragraph
      flushList(); 
      html += `<p>${applyInline(line)}</p>`; 
    } 
    
    flushList(); 
    return sanitizeHTML(html); 
  }
  function sanitizeHTML(html){ const allowed = new Set(['H1','H2','H3','H4','H5','H6','P','STRONG','EM','U','UL','LI','BR']); const tmp = document.createElement('div'); tmp.innerHTML = html; (function walk(node){ const children = Array.from(node.childNodes); for (const child of children){ if (child.nodeType === 1){ if (!allowed.has(child.tagName)){ while (child.firstChild) node.insertBefore(child.firstChild, child); node.removeChild(child); continue; } const attrs = Array.from(child.attributes); for (const a of attrs) child.removeAttribute(a.name); walk(child); } } })(tmp); return tmp.innerHTML; }
  function updatePreview(){ previewEl.innerHTML = renderMarkdown(editor.value || ''); }

  // =========================
  //  AI Helper Functions
  // =========================
  function updateGenerateButton() {
    const hasKey = openrouterKey.value.trim().length > 0;
    const hasModel = aiModel.value.trim().length > 0;
    const canGenerate = hasKey && hasModel && !isGenerating;
    

    
    // Update fixed button
    fixedGenerateBtn.disabled = !canGenerate;
    fixedGenerateBtn.classList.toggle('visible', hasKey && hasModel);
    
    updateCostEstimate();
  }

  function updateCostEstimate() {
    if (!aiModel.value || !maxTokensInput.value) {
      costEstimate.textContent = '~$0.00 per generation';
      return;
    }
    
    // Basic cost estimation (simplified)
    const tokens = parseInt(maxTokensInput.value) || 1000;
    const modelCosts = {
      'anthropic/claude-3.5-sonnet': 0.000015,
      'anthropic/claude-3-haiku': 0.00000025,
      'openai/gpt-4o': 0.00001,
      'openai/gpt-4o-mini': 0.00000015,
      'meta-llama/llama-3.1-70b-instruct': 0.0000009,
      'meta-llama/llama-3.1-8b-instruct': 0.00000006
    };
    
    const costPerToken = modelCosts[aiModel.value] || 0.000001;
    const estimatedCost = tokens * costPerToken;
    
    costEstimate.textContent = `~$${estimatedCost.toFixed(4)} per generation`;
  }

  async function refreshAvailableModels() {
    if (!openrouterKey.value.trim()) {
      setStatus("Please enter OpenRouter API key first.");
      return;
    }
    
    try {
      setStatus("Fetching available models...");
      
      const response = await fetch("https://openrouter.ai/api/v1/models", {
        headers: {
          "Authorization": `Bearer ${openrouterKey.value.trim()}`,
        }
      });
      
      if (!response.ok) {
        throw new Error(`Failed to fetch models: ${response.status}`);
      }
      
      const data = await response.json();
      const models = data.data || [];
      
      // Store models for search functionality
      availableModels = models.map(model => {
        const pricing = model.pricing?.prompt || 0;
        const pricingNum = typeof pricing === 'number' ? pricing : parseFloat(pricing) || 0;
        return {
          id: model.id,
          name: model.id,
          pricing: pricingNum,
          displayText: `${model.id} - $${pricingNum.toFixed(6)}/1K tokens`
        };
      });
      
      setStatus("Models updated successfully.");
    } catch (error) {
      console.error("Failed to fetch models:", error);
      setStatus(`Failed to fetch models: ${error.message}`);
    }
  }

  function filterModels(searchTerm) {
    const filtered = availableModels.filter(model => 
      model.id.toLowerCase().includes(searchTerm.toLowerCase())
    );
    
    modelDropdown.innerHTML = '';
    
    if (filtered.length > 0 && searchTerm.trim() !== '') {
      modelDropdown.style.display = 'block';
      filtered.slice(0, 10).forEach(model => { // Limit to 10 results
        const item = document.createElement('div');
        item.style.cssText = 'padding: 8px 12px; cursor: pointer; border-bottom: 1px solid #eee; font-size: 13px;';
        item.textContent = model.displayText;
        item.addEventListener('click', () => {
          aiModel.value = model.id;
          modelDropdown.style.display = 'none';
          updateGenerateButton();
          markDirty();
          saveAISettings();
        });
        item.addEventListener('mouseenter', () => {
          item.style.backgroundColor = '#f5f5f5';
        });
        item.addEventListener('mouseleave', () => {
          item.style.backgroundColor = 'white';
        });
        modelDropdown.appendChild(item);
      });
    } else {
      modelDropdown.style.display = 'none';
    }
  }

  function setGenerationState(generating) {
    isGenerating = generating;
    
    // Update UI elements
    fixedGenerateBtn.classList.toggle('generating', generating);
    fixedGenerateBtn.textContent = generating ? 'Generating...' : 'Generate with AI';
    fixedGenerateBtn.disabled = generating;
    
    cancelGenerateBtn.classList.toggle('visible', generating);
    
    // Disable/enable editor during generation
    editor.disabled = generating;
    if (generating) {
      editor.style.opacity = '0.7';
      editor.style.pointerEvents = 'none';
    } else {
      editor.style.opacity = '1';
      editor.style.pointerEvents = 'auto';
    }
    
    updateGenerateButton();
  }

  function cancelGeneration() {
    if (generationController) {
      generationController.abort();
      generationController = null;
    }
    setGenerationState(false);
    setStatus("Generation cancelled.");
  }

  async function generateAIContent() {
    if (!openrouterKey.value.trim() || !aiModel.value.trim()) {
      setStatus("Please enter OpenRouter API key and select a model.");
      return;
    }

    if (isGenerating) {
      setStatus("Generation already in progress.");
      return;
    }

    try {
      generationController = new AbortController();
      setGenerationState(true);
      setStatus("Generating AI content...");

      // Get the current editor content
      const currentContent = editor.value || "";
      
      // Apply max input length limit - keep only recent paragraphs if content is too long
      let limitedContent = currentContent;
      const maxInputLength = 8000; // Approximate character limit to stay under token limits
      
      if (currentContent.length > maxInputLength) {
        const paragraphs = currentContent.split(/\n\s*\n/).filter(p => p.trim());
        let totalLength = 0;
        const recentParagraphs = [];
        
        // Work backwards from the end to include the most recent paragraphs
        for (let i = paragraphs.length - 1; i >= 0; i--) {
          const paragraph = paragraphs[i];
          if (totalLength + paragraph.length > maxInputLength && recentParagraphs.length > 0) {
            break;
          }
          recentParagraphs.unshift(paragraph);
          totalLength += paragraph.length + 2; // +2 for paragraph separator
        }
        
        limitedContent = recentParagraphs.join('\n\n');
        if (recentParagraphs.length < paragraphs.length) {
          setStatus(`Content truncated to recent ${recentParagraphs.length} paragraphs due to length limit.`);
        }
      }
      
      // Build the prompt
      let prompt = "";
      if (aiPreInput.value.trim()) {
        prompt += `[${aiPreInput.value.trim()}]\n\n`;
      }
      prompt += limitedContent;
      
      // Add next instructions if enabled - append to most recent complete paragraph
      if (nextEnabled.checked && nextInstInput.value.trim()) {
        // Find paragraphs (separated by double newlines or end of text)
        const paragraphs = limitedContent.split(/\n\s*\n/).filter(p => p.trim());
        if (paragraphs.length > 0) {
          // Check if the last paragraph looks complete (ends with punctuation)
          const lastParagraph = paragraphs[paragraphs.length - 1].trim();
          if (lastParagraph && /[.!?]$/.test(lastParagraph)) {
            prompt += `\n\n[${nextInstInput.value.trim()}]`;
          } else {
            // If no complete paragraph, just add instructions at the end
            prompt += `\n\n[${nextInstInput.value.trim()}]`;
          }
        } else {
          // No paragraphs yet, add instructions
          prompt += `\n\n[${nextInstInput.value.trim()}]`;
        }
      }

      // Build request body with enhanced settings
      const requestBody = {
        model: aiModel.value,
        messages: [
          {
            role: "user",
            content: prompt
          }
        ],
        max_tokens: parseInt(maxTokensInput.value) || 1000,
        temperature: parseFloat(temperatureInput.value) || 0.7,
        top_p: parseFloat(topPInput.value) || 1.0
      };

      // Add top_k if specified
      if (topKInput.value && parseInt(topKInput.value) > 0) {
        requestBody.top_k = parseInt(topKInput.value);
      }

      // Call OpenRouter API
      const response = await fetch("https://openrouter.ai/api/v1/chat/completions", {
        method: "POST",
        headers: {
          "Authorization": `Bearer ${openrouterKey.value.trim()}`,
          "Content-Type": "application/json",
          "HTTP-Referer": window.location.origin,
          "X-Title": "Ghostwriter"
        },
        body: JSON.stringify(requestBody),
        signal: generationController.signal
      });

      if (!response.ok) {
        let errorMessage = `OpenRouter API error: ${response.status} ${response.statusText}`;
        const errorText = await response.text();
        
        // Provide helpful error messages for common issues
        if (response.status === 401) {
          errorMessage = "Invalid API key. Please check your OpenRouter API key.";
        } else if (response.status === 429) {
          errorMessage = "Rate limit exceeded. Please wait a moment and try again.";
        } else if (response.status === 402) {
          errorMessage = "Insufficient credits. Please check your OpenRouter account balance.";
        } else if (errorText) {
          try {
            const errorData = JSON.parse(errorText);
            if (errorData.error?.message) {
              errorMessage += `: ${errorData.error.message}`;
            }
          } catch {
            errorMessage += `: ${errorText}`;
          }
        }
        
        throw new Error(errorMessage);
      }

      const data = await response.json();
      const generatedText = data.choices?.[0]?.message?.content?.trim();

      if (!generatedText) {
        throw new Error("No content generated from AI model.");
      }

      // Insert the generated content at the cursor position or end of editor
      const { start, end } = getSelection(editor);
      const before = editor.value.slice(0, start);
      const after = editor.value.slice(end);
      
      // Add appropriate spacing
      let insertText = generatedText;
      if (before && !before.endsWith('\n\n')) {
        insertText = '\n\n' + insertText;
      }
      
      const newValue = before + insertText + after;
      const newCursorPos = start + insertText.length;
      
      applyChange(newValue, newCursorPos, newCursorPos);
      updatePreview();
      
      setStatus("AI content generated successfully.");
    } catch (error) {
      if (error.name === 'AbortError') {
        setStatus("Generation cancelled.");
      } else {
        console.error("AI generation error:", error);
        setStatus(`AI generation failed: ${error.message}`);
      }
    } finally {
      setGenerationState(false);
      generationController = null;
    }
  }

  // =========================
  //  AI Settings Persistence (Google Drive AppData)
  // =========================
  async function findAISettingsFile() {
    try {
      const url = new URL(DRIVE_FILES_URL);
      url.searchParams.set("q", `name='${AI_SETTINGS_FILENAME}' and parents in 'appdata'`);
      url.searchParams.set("spaces", "appdata");
      url.searchParams.set("fields", "files(id,name)");
      
      const res = await fetch(url.toString(), { headers: authHeader() });
      if (res.status === 401) { await refreshToken(); return findAISettingsFile(); }
      if (!res.ok) throw new Error(`Find AI settings failed: ${res.status}`);
      
      const { files } = await res.json();
      return files && files.length > 0 ? files[0].id : null;
    } catch (e) {
      console.warn("Failed to find AI settings file:", e);
      return null;
    }
  }

  async function loadAISettings() {
    if (!accessToken || aiSettingsLoaded) return;
    
    try {
      aiSettingsFileId = await findAISettingsFile();
      if (!aiSettingsFileId) {
        aiSettingsLoaded = true;
        return; // No settings file exists yet
      }

      const res = await fetch(`${DRIVE_FILES_URL}/${aiSettingsFileId}?alt=media`, { headers: authHeader() });
      if (res.status === 401) { await refreshToken(); return loadAISettings(); }
      if (!res.ok) throw new Error(`Load AI settings failed: ${res.status}`);
      
      const settingsText = await res.text();
      const settings = JSON.parse(settingsText);
      
      // Apply settings to UI (but only if remember_key is true for API key)
      if (settings.ai_model) {
        aiModel.value = settings.ai_model;
      }
      if (settings.remember_key && settings.openrouter_key) {
        openrouterKey.value = settings.openrouter_key;
        rememberKey.checked = true;
      } else {
        rememberKey.checked = false;
      }
      
      updateGenerateButton();
      aiSettingsLoaded = true;
      console.log("AI settings loaded from Drive");
    } catch (e) {
      console.warn("Failed to load AI settings:", e);
      aiSettingsLoaded = true;
    }
  }

  async function saveAISettings() {
    if (!accessToken) return;
    
    try {
      const settings = {
        ai_model: aiModel.value || "",
        remember_key: !!rememberKey.checked,
        openrouter_key: rememberKey.checked ? (openrouterKey.value || "") : "",
        last_updated: new Date().toISOString()
      };
      
      const settingsJson = JSON.stringify(settings, null, 2);
      
      if (aiSettingsFileId) {
        // Update existing file
        const res = await fetch(`${DRIVE_UPLOAD_URL}/${aiSettingsFileId}?uploadType=media`, {
          method: "PATCH",
          headers: { ...authHeader(), "Content-Type": "application/json; charset=UTF-8" },
          body: settingsJson
        });
        if (res.status === 401) { await refreshToken(); return saveAISettings(); }
        if (!res.ok) throw new Error(`Update AI settings failed: ${res.status}`);
      } else {
        // Create new file in appdata folder
        const boundary = "-------AISettings-" + Math.random().toString(36).slice(2);
        const metadata = { 
          name: AI_SETTINGS_FILENAME, 
          parents: ["appdata"],
          mimeType: "application/json"
        };
        const body = `--${boundary}\r\n` +
          `Content-Type: application/json; charset=UTF-8\r\n\r\n` +
          JSON.stringify(metadata) + `\r\n` +
          `--${boundary}\r\n` +
          `Content-Type: application/json; charset=UTF-8\r\n\r\n` +
          settingsJson + `\r\n` +
          `--${boundary}--`;
          
        const res = await fetch(`${DRIVE_UPLOAD_URL}?uploadType=multipart&fields=id`, {
          method: "POST",
          headers: { ...authHeader(), "Content-Type": `multipart/related; boundary=${boundary}` },
          body
        });
        if (res.status === 401) { await refreshToken(); return saveAISettings(); }
        if (!res.ok) throw new Error(`Create AI settings failed: ${res.status}`);
        
        const result = await res.json();
        aiSettingsFileId = result.id;
      }
      
      console.log("AI settings saved to Drive");
    } catch (e) {
      console.warn("Failed to save AI settings:", e);
    }
  }

  // =========================
  //  Drive helpers (fetch)
  // =========================
  function authHeader() { return { Authorization: `Bearer ${accessToken}` }; }
  async function createTextFile(name, text) { const boundary = "-------Ghostwriter-" + Math.random().toString(36).slice(2); const metadata = { name, mimeType: "text/plain", appProperties: { Ghostwriter: "1" } }; const body = `--${boundary}\r\n` + `Content-Type: application/json; charset=UTF-8\r\n\r\n` + JSON.stringify(metadata) + `\r\n` + `--${boundary}\r\n` + `Content-Type: text/plain; charset=UTF-8\r\n\r\n` + (text || "") + `\r\n` + `--${boundary}--`; const res = await fetch(`${DRIVE_UPLOAD_URL}?uploadType=multipart&fields=id,name,webViewLink,modifiedTime`, { method: "POST", headers: { ...authHeader(), "Content-Type": `multipart/related; boundary=${boundary}` }, body }); if (res.status === 401) { await refreshToken(); return createTextFile(name, text); } if (!res.ok) throw new Error(`Create failed: ${res.status}`); return await res.json(); }
  async function updateTextFile(fileId, text) { const res = await fetch(`${DRIVE_UPLOAD_URL}/${fileId}?uploadType=media&fields=id,name,modifiedTime,webViewLink`, { method: "PATCH", headers: { ...authHeader(), "Content-Type": "text/plain; charset=UTF-8" }, body: text || "" }); if (res.status === 401) { await refreshToken(); return updateTextFile(fileId, text); } if (!res.ok) throw new Error(`Update failed: ${res.status}`); return await res.json(); }
  async function downloadTextFile(fileId) { const res = await fetch(`${DRIVE_FILES_URL}/${fileId}?alt=media`, { headers: authHeader() }); if (res.status === 401) { await refreshToken(); return downloadTextFile(fileId); } if (!res.ok) throw new Error(`Download failed: ${res.status}`); return await res.text(); }
  async function getMeta(fileId) { const res = await fetch(`${DRIVE_FILES_URL}/${fileId}?fields=id,name,modifiedTime`, { headers: authHeader() }); if (res.status === 401) { await refreshToken(); return getMeta(fileId); } if (!res.ok) throw new Error(`Meta failed: ${res.status}`); return await res.json(); }
  async function listGhostwriterFiles() { const q = ["mimeType='text/plain'","appProperties has { key='Ghostwriter' and value='1' }"]; const url = new URL(DRIVE_FILES_URL); url.searchParams.set("q", q.join(" and ")); url.searchParams.set("orderBy", "modifiedTime desc"); url.searchParams.set("pageSize", "100"); url.searchParams.set("fields", "files(id,name,modifiedTime)"); const res = await fetch(url.toString(), { headers: authHeader() }); if (res.status === 401) { await refreshToken(); return listGhostwriterFiles(); } if (!res.ok) throw new Error(`List failed: ${res.status}`); const { files } = await res.json(); return files || []; }
  async function refreshToken(){ return new Promise((resolve) => { tokenClient.callback = () => resolve(); tokenClient.requestAccessToken({ prompt: "" }); }); }

  // =========================
  //  App actions (now include JSON header)
  // =========================
  async function createNewFile() {
    try {
      setStatus("Creating file…");
      const title = `GhostWriter ${new Date().toISOString().replace(/[:.]/g, "-")}.txt`;
      const combined = buildFileText(readMetaFromUI(), editor.value || "");
      const meta = await createTextFile(title, combined);
      setActiveFile(meta.id, meta.name);
      lastRemoteModified = Date.parse(meta.modifiedTime || Date.now());
      startPolling();
      setStatus("File created and syncing.");
      const u = new URL(location.href); u.searchParams.set("file", meta.id); history.replaceState({}, "", u.toString());
      updatePreview();
    } catch (e) { console.error(e); setStatus("Failed to create file. See console."); }
  }

  async function loadFile(id) {
    try {
      setStatus("Loading file…");
      const meta = await getMeta(id);
      const raw = await downloadTextFile(id);
      const parsed = parseFileText(raw);
      writeMetaToUI(parsed.meta);
      editor.value = parsed.content;
      setActiveFile(id, meta.name || "(unknown)");
      lastRemoteModified = Date.parse(meta.modifiedTime || 0);
      startPolling();
      setStatus("Loaded and syncing.");
      const u = new URL(location.href); u.searchParams.set("file", id); history.replaceState({}, "", u.toString());
      updatePreview();
    } catch (e) { console.error(e); setStatus("Failed to load file. Check ID and permissions."); }
  }

  function scheduleAutosave(){ clearTimeout(autosaveTimer); autosaveTimer = setTimeout(() => flushSave(), AUTOSAVE_DELAY); }

  async function flushSave(opts={}) {
    if (!currentFileId || !accessToken) return;
    if (!dirty && !opts.force) return;
    try {
      isSaving = true; setSaveDot("saving"); if (!opts.silent) setStatus("Saving…");
      const combined = buildFileText(readMetaFromUI(), editor.value);
      const res = await updateTextFile(currentFileId, combined);
      lastRemoteModified = Date.parse(res.modifiedTime || Date.now());
      dirty = false; isSaving = false; setSaveDot("saved"); if (!opts.silent) setStatus("Saved.");
      syncNote.textContent = `Auto-saved at ${new Date().toLocaleTimeString()}`;
      setTimeout(() => { if (!dirty) setSaveDot("idle"); }, 1200);
    } catch (e) { console.error(e); isSaving = false; setSaveDot("idle"); setStatus("Save failed. Will retry on next edit."); }
  }

  function startPolling(){ stopPolling(); pollTimer = setInterval(checkRemoteChanges, POLL_INTERVAL); }
  function stopPolling(){ if (pollTimer) clearInterval(pollTimer); pollTimer = null; }

  async function checkRemoteChanges(){
    if (!currentFileId || !accessToken) return;
    const now = Date.now();
    if (isSaving) return;
    if (dirty && now - lastInputTs < IDLE_GRACE) return;
    try {
      const meta = await getMeta(currentFileId);
      const remoteTs = Date.parse(meta.modifiedTime || 0);
      if (remoteTs > lastRemoteModified && !dirty) {
        const raw = await downloadTextFile(currentFileId);
        const parsed = parseFileText(raw);
        writeMetaToUI(parsed.meta);
        editor.value = parsed.content;
        lastRemoteModified = remoteTs;
        syncNote.textContent = `Updated from Drive at ${new Date().toLocaleTimeString()}`;
        setStatus("Pulled latest changes from Drive.");
        updatePreview();
      }
    } catch (e) { console.warn("Polling error", e); }
  }

  async function refreshList() {
    try { setStatus("Listing files…"); const files = await listGhostwriterFiles(); listBody.innerHTML = files.map(f => { const when = new Date(f.modifiedTime).toLocaleString(); const openHere = `<button data-open="${f.id}">Open here</button>`; const link = `https://drive.google.com/file/d/${f.id}/view`; return `<tr><td>${escapeHtml(f.name)}</td><td>${when}</td><td>${openHere} <a href="${link}" target="_blank" rel="noreferrer">Drive</a></td></tr>`; }).join(""); listBody.querySelectorAll("button[data-open]").forEach(btn => { btn.addEventListener("click", () => loadFile(btn.getAttribute("data-open"))); }); setStatus("Ready."); } catch (e) { console.error(e); setStatus("List failed. See console."); }
  }

  // NOTE: This overrides the earlier one (intentionally more strict for list rendering)
  function escapeHtml(str){ return String(str).replaceAll('&','&amp;').replaceAll('<','&lt;').replaceAll('>','&gt;').replaceAll('"','&quot;').replaceAll("'", '&#039;'); }
</script>
</body>
</html>
