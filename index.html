<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>GhostWriter</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <!-- Google Identity Services (OAuth in browser) -->
  <script src="https://accounts.google.com/gsi/client" async defer></script>
  <style>
    :root { 
      --bg:#ffffff; --muted:#f6f6f6; --line:#e8e8e8; --ink:#111; --sub:#555; --meta-w: 380px; 
      --editor-font-size: 14px;
      --editor-font-family: 'SF Mono', Monaco, 'Cascadia Code', 'Roboto Mono', Consolas, 'Courier New', monospace;
    }
    
    /* Font family options */
    [data-font-family="mono"] { --editor-font-family: 'SF Mono', Monaco, 'Cascadia Code', 'Roboto Mono', Consolas, 'Courier New', monospace; }
    [data-font-family="serif"] { --editor-font-family: Georgia, 'Times New Roman', Times, serif; }
    [data-font-family="sans-serif"] { --editor-font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; }
    
    /* Dark mode variables */
    [data-theme="dark"] {
      --bg:#1a1a1a; --muted:#2d2d2d; --line:#404040; --ink:#e0e0e0; --sub:#aaa;
    }
    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body { margin: 0; background: var(--bg); color: var(--ink); font: 14px/1.45 system-ui, -apple-system, Segoe UI, Roboto, sans-serif; }

    /* App shell: header • main • footer */
    .app { display: grid; grid-template-rows: auto 1fr auto; height: 100vh; }
    header, #app-footer { background: var(--muted); border-bottom: 1px solid var(--line); }

    /* Toolbar */
    .toolbar { padding: 10px 14px; display: flex; gap: 8px; flex-wrap: wrap; align-items: center; }
    .toolbar .row { display: flex; align-items: center; gap: 8px; flex-wrap: wrap; }
    .toolbar button, .toolbar select { padding: 8px 10px; border: 1px solid var(--line); background: var(--bg); color: var(--ink); border-radius: 10px; cursor: pointer; }
    .toolbar button[disabled] { opacity: 0.5; cursor: not-allowed; }
    .toolbar input[type="text"] { flex: 1; min-width: 220px; padding: 8px; border-radius: 10px; border: 1px solid var(--line); background: var(--bg); color: var(--ink); }

    /* File list dropdown */
    #list-panel { max-height: 40vh; overflow: auto; border-top: 1px solid var(--line); background: var(--bg); color: var(--ink); display: none; }
    #list-panel table { width: 100%; border-collapse: collapse; font-size: 13px; }
    #list-panel th, #list-panel td { padding: 8px 12px; border-bottom: 1px solid var(--line); }
    #list-panel tr:hover { background: var(--muted); }

    /* Main editor/preview area */
    main.main { display: grid; grid-template-columns: 1fr; height: 100%; min-height: 0; width: 100%; margin: 0 auto; }
    #editor-wrap, #preview { min-height: 0; }
    #editor { 
      width: 100%; height: 100%; padding: 16px; border: none; outline: none; resize: none;
      font: var(--editor-font-size, 14px)/1.6 var(--editor-font-family, 'SF Mono', Monaco, 'Cascadia Code', 'Roboto Mono', Consolas, 'Courier New', monospace);
      max-width: none; background: var(--bg); color: var(--ink);
      /* Better mobile experience */
      -webkit-appearance: none;
      -moz-appearance: none;
      appearance: none;
      -webkit-text-size-adjust: 100%;
      text-size-adjust: 100%;
      -webkit-user-select: text;
      user-select: text;
      /* Better touch handling on mobile */
      touch-action: manipulation;
      /* Prevent zoom on iOS */
      font-size: max(16px, var(--editor-font-size, 14px));
    }
    
    /* Mobile-specific improvements */
    @media (max-width: 768px) {
      #editor {
        /* Ensure minimum font size to prevent zoom on iOS */
        font-size: 16px;
        line-height: 1.5;
        /* Better spacing on mobile */
        padding: 20px 16px;
      }
    }
    
    /* Focus styles for better mobile UX */
    #editor:focus {
      outline: none;
      /* Subtle focus indication */
      box-shadow: inset 0 0 0 2px rgba(0, 123, 255, 0.25);
    }
    #preview { display:none; padding: 18px; overflow:auto; background: var(--bg); color: var(--ink); border-left: 1px solid var(--line); }

    /* Responsive text area constraints */
    @media (min-width: 768px) {
      main.main { max-width: 1200px; margin: 0 auto; padding: 0 20px; }
      /* Add comfortable reading width for editor in non-split mode */
      body:not([data-mode="split"]) #editor { max-width: 800px; margin: 0 auto; }
    }
    @media (min-width: 1200px) {
      main.main { max-width: 1600px; padding: 0 40px; }
      body:not([data-mode="split"]) #editor { max-width: 900px; margin: 0 auto; }
    }
    @media (min-width: 1400px) {
      main.main { max-width: 1800px; padding: 0 60px; }
      body:not([data-mode="split"]) #editor { max-width: 1000px; margin: 0 auto; }
    }

    /* Split / Preview-only modes */
    body[data-mode="split"] main.main { grid-template-columns: 1fr 1fr; }
    body[data-mode="split"] #preview { display:block; }
    body[data-mode="preview"] #editor-wrap { display:none; }
    body[data-mode="preview"] #preview { display:block; }

    /* Preview typography */
    #preview h1, #preview h2, #preview h3, #preview h4, #preview h5, #preview h6 { margin: 1.2em 0 0.5em; line-height:1.2; }
    #preview h1 { font-size: 1.6rem; }
    #preview h2 { font-size: 1.4rem; }
    #preview h3 { font-size: 1.25rem; }
    #preview p { margin: 0.5em 0; }
    #preview ul { margin: 0.5em 0 0.5em 1.2em; }
    #preview li { margin: 0.25em 0; }

    .pill { display: inline-block; padding: 3px 10px; border-radius: 999px; background: #eee; font-size: 12px; }
    a { color: inherit; }
    code.kbd { padding: 2px 6px; border: 1px solid var(--line); border-radius: 6px; background: #fbfbfb; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; }
    .dot { width:8px; height:8px; border-radius:999px; background:#bbb; display:inline-block; }
    .dot.saving { background:#d69e2e; }
    .dot.saved { background:#38a169; }
    .dot.idle { background:#bbb; }

    /* ========================= */
    /* Side Metadata Panel (Drawer) */
    /* ========================= */
    #meta-panel {
      position: fixed;
      top: 0; right: 0;
      height: 100vh; width: var(--meta-w);
      background: var(--bg);
      border-left: 1px solid var(--line);
      box-shadow: -8px 0 24px rgba(0,0,0,0.06);
      transform: translateX(100%);
      transition: transform 220ms ease;
      z-index: 50;
      display: grid;
      grid-template-rows: auto auto 1fr auto;
    }
    #meta-panel[data-open="1"] { transform: translateX(0); }

    /* Panel header */
    #meta-head { display: flex; align-items: center; justify-content: space-between; gap: 8px; padding: 10px 12px; border-bottom: 1px solid var(--line); background: var(--muted); }
    #meta-title { font-size: 13px; color: var(--ink); font-weight: 600; }
    #meta-close, #meta-toggle, #meta-save-now { padding: 6px 10px; border: 1px solid var(--line); background: var(--bg); color: var(--ink); border-radius: 8px; cursor: pointer; }

    /* Panel tabs */
    #meta-tabs {
      display: flex;
      border-bottom: 1px solid var(--line);
      background: var(--muted);
    }
    .meta-tab-btn {
      flex: 1 0 auto;
      padding: 6px 10px;
      border: none;
      background: transparent;
      font: 11px/1.3 system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      font-weight: 500;
      color: var(--sub);
      cursor: pointer;
      border-bottom: 2px solid transparent;
      transition: all 150ms ease;
    }
    .meta-tab-btn:hover {
      background: var(--muted);
      color: var(--ink);
    }
    .meta-tab-btn.active {
      background: var(--bg);
      color: var(--ink);
      border-bottom-color: #4a90e2;
      font-weight: 600;
    }

    /* Panel body */
    #meta-body { padding: 10px 12px; overflow: auto; position: relative; }
    .tab-content {
      display: none;
    }
    .tab-content.active {
      display: grid;
      gap: 10px;
    }
    #meta-body .row { display:grid; grid-template-columns: 1fr; gap: 6px; }
    #meta-body label { font-size: 12px; color: var(--ink); }
    #meta-body textarea { width: 100%; min-height: 100px; max-height: 45vh; padding: 8px; resize: vertical; border: 1px solid var(--line); border-radius: 8px; background: var(--bg); color: var(--ink); font: 13px/1.45 ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; }
    #meta-body input[type="password"], #meta-body input[type="number"], #meta-body select { width: 100%; padding: 8px; border: 1px solid var(--line); border-radius: 8px; background: var(--bg); color: var(--ink); font: 13px/1.45 system-ui, -apple-system, Segoe UI, Roboto, sans-serif; }
    #meta-body input[type="range"] { width: 100%; }
    #meta-body input[type="password"] { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; }
    #meta-body button { padding: 10px 12px; border: 1px solid var(--line); background: var(--bg); color: var(--ink); border-radius: 8px; cursor: pointer; font: 13px/1.45 system-ui, -apple-system, Segoe UI, Roboto, sans-serif; font-weight: 600; }
    #meta-body button:hover:not(:disabled) { background: var(--muted); }
    #meta-body button:disabled { opacity: 0.5; cursor: not-allowed; }
    #meta-body button.generating { background: #f0f8ff; border-color: #4a90e2; }
    #next-enable-wrap { display:flex; align-items:center; justify-content:flex-end; gap: 8px; }
    .range-value { font-size: 12px; color: var(--sub); margin-left: 8px; }

    /* Panel footer */
    #meta-foot { padding: 8px 12px; border-top: 1px solid var(--line); font-size:12px; color: var(--sub); display:flex; justify-content: space-between; align-items:center; gap: 8px; }

    /* Scrim behind drawer */
    #meta-scrim {
      position: fixed; inset: 0; background: rgba(0,0,0,0.18);
      opacity: 0; pointer-events: none; transition: opacity 200ms ease; z-index: 40;
    }
    #meta-scrim[data-open="1"] { opacity: 1; pointer-events: auto; }

    /* Side tab button */
    #meta-tab[aria-disabled="true"] { opacity: 0.5; cursor: not-allowed; }

    /* ========================= */
    /* File Modal */
    /* ========================= */
    #file-modal {
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(0,0,0,0.5);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 1000;
    }
    #file-modal[data-open="1"] { display: flex; }
    
    #file-modal-content {
      background: var(--bg);
      border: 1px solid var(--line);
      border-radius: 12px;
      box-shadow: 0 8px 32px rgba(0,0,0,0.2);
      width: 90vw;
      max-width: 500px;
      max-height: 80vh;
      display: grid;
      grid-template-rows: auto 1fr auto;
    }
    
    #file-modal-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 16px 20px;
      border-bottom: 1px solid var(--line);
      background: var(--muted);
      border-radius: 12px 12px 0 0;
    }
    
    #file-modal-title {
      font-size: 16px;
      font-weight: 600;
      color: var(--ink);
    }
    
    #file-modal-close {
      padding: 8px;
      border: none;
      background: none;
      color: var(--sub);
      cursor: pointer;
      border-radius: 6px;
      font-size: 18px;
    }
    
    #file-modal-close:hover {
      background: var(--line);
      color: var(--ink);
    }
    
    #file-modal-body {
      padding: 20px;
      overflow-y: auto;
    }
    
    .file-action {
      display: flex;
      gap: 12px;
      margin-bottom: 16px;
    }
    
    .file-action button {
      flex: 1;
      padding: 12px 16px;
      border: 1px solid var(--line);
      background: var(--bg);
      color: var(--ink);
      border-radius: 8px;
      cursor: pointer;
      font-weight: 500;
    }
    
    .file-action button:hover:not(:disabled) {
      background: var(--muted);
    }
    
    .file-action button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    
    #file-list-section {
      border-top: 1px solid var(--line);
      padding-top: 16px;
      margin-top: 16px;
    }
    
    #file-list-section h3 {
      margin: 0 0 12px 0;
      font-size: 14px;
      font-weight: 600;
      color: var(--ink);
    }

    /* Responsive niceties */
    @media (max-width: 480px) {
      :root { --meta-w: 92vw; }
      /* Hide Split button on mobile */
      #toggle-split { display: none; }
      /* Position Settings button in toolbar area on mobile */
      #meta-tab { 
        position: fixed;
        top: 147px; /* Position after toolbar */
        right: 8px;
        transform: none; 
        writing-mode: horizontal-tb; 
        border: 1px solid var(--line); 
        border-radius: 10px; 
        padding: 8px 10px; 
        font-size: 14px;
        box-shadow: 0 2px 6px rgba(0,0,0,0.1);
        z-index: 60;
        background: var(--bg);
        color: var(--ink);
      }
      /* Move Generate button to bottom left on mobile to avoid covering settings button */
      #fixed-generate-btn { left: 20px; right: auto; }
    }

    /* Desktop styles for settings button - keep original positioning */
    @media (min-width: 481px) {
      #meta-tab {
        position: fixed; 
        right: 0; 
        top: 50%; 
        transform: translate(50%, -50%);
        writing-mode: vertical-rl; 
        text-orientation: mixed;
        background: var(--bg); 
        color: var(--ink); 
        border: 1px solid var(--line); 
        border-right: none; 
        border-radius: 10px 0 0 10px;
        padding: 10px 8px; 
        font-size: 12px; 
        cursor: pointer; 
        z-index: 60;
        box-shadow: -4px 4px 12px rgba(0,0,0,0.06);
      }
    }

    /* ========================= */
    /* Generate Button - New Positioning */
    /* ========================= */
    #fixed-generate-btn {
      position: fixed;
      bottom: 80px; /* Always positioned above footer */
      right: 20px;
      padding: 12px 24px;
      background: #4a90e2;
      color: white;
      border: none;
      border-radius: 12px;
      font: 14px/1.4 system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      font-weight: 600;
      cursor: pointer;
      box-shadow: 0 4px 12px rgba(74, 144, 226, 0.3);
      transition: all 200ms ease;
      z-index: 100;
      display: none;
    }
    
    #fixed-generate-btn:hover:not(:disabled) {
      background: #357abd;
      transform: translateY(-1px);
      box-shadow: 0 6px 16px rgba(74, 144, 226, 0.4);
    }
    
    #fixed-generate-btn:disabled {
      background: #ccc;
      cursor: not-allowed;
      transform: none;
      box-shadow: 0 2px 6px rgba(0,0,0,0.1);
    }
    
    #fixed-generate-btn.generating {
      background: #f0c14b;
      color: #333;
    }
    
    #fixed-generate-btn.visible {
      display: block;
    }

    /* Adjust generate button position based on footer content */
    @media (max-width: 768px) {
      #fixed-generate-btn {
        left: 20px;
        right: auto;
        bottom: 80px; /* Base position above footer */
      }
      
      /* When pagination is active, move button higher */
      body[data-pagination-active="true"] #fixed-generate-btn {
        bottom: 140px; /* Position above footer with pagination */
      }
    }

    @media (min-width: 769px) {
      /* When pagination is active on desktop, adjust slightly */
      body[data-pagination-active="true"] #fixed-generate-btn {
        bottom: 120px;
      }
    }

    /* Cancel button */
    #cancel-generate-btn {
      position: fixed;
      bottom: 80px; /* Positioned above footer, next to generate button */
      right: 180px;
      padding: 8px 16px;
      background: #dc3545;
      color: white;
      border: none;
      border-radius: 8px;
      font: 12px/1.4 system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      font-weight: 600;
      cursor: pointer;
      box-shadow: 0 2px 8px rgba(220, 53, 69, 0.3);
      transition: all 200ms ease;
      z-index: 100;
      display: none;
    }
    
    #cancel-generate-btn:hover {
      background: #c82333;
      transform: translateY(-1px);
    }
    
    #cancel-generate-btn.visible {
      display: block;
    }

    #undo-generate-btn {
      position: fixed;
      bottom: 80px; /* Positioned above footer, next to cancel button */
      right: 340px; /* Further left from cancel button */
      padding: 8px 16px;
      background: #6c757d;
      color: white;
      border: none;
      border-radius: 8px;
      font: 12px/1.4 system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      font-weight: 600;
      cursor: pointer;
      box-shadow: 0 2px 8px rgba(108, 117, 125, 0.3);
      transition: all 200ms ease;
      z-index: 100;
      display: none;
    }
    
    #undo-generate-btn:hover {
      background: #5a6268;
      transform: translateY(-1px);
    }
    
    #undo-generate-btn.visible {
      display: block;
    }

    @media (max-width: 768px) {
      #cancel-generate-btn {
        left: 180px;
        right: auto;
        bottom: 80px;
      }
      
      #undo-generate-btn {
        left: 20px; /* Position to the left on mobile */
        right: auto;
        bottom: 140px; /* Above the cancel button */
      }
      
      body[data-pagination-active="true"] #cancel-generate-btn {
        bottom: 140px;
      }
      
      body[data-pagination-active="true"] #undo-generate-btn {
        bottom: 200px; /* Adjust when pagination is active */
      }
    }

    @media (min-width: 769px) {
      body[data-pagination-active="true"] #cancel-generate-btn {
        bottom: 120px;
      }
      
      body[data-pagination-active="true"] #undo-generate-btn {
        bottom: 120px; /* Keep same level as cancel button */
      }
    }

    /* ========================= */
    /* Story Dex Modal */
    /* ========================= */
    .story-dex-modal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 1000;
      display: none;
    }
    .story-dex-modal[data-open="1"] {
      display: block;
    }
    .story-dex-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.5);
    }
    .story-dex-content {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: var(--bg);
      color: var(--ink);
      border-radius: 12px;
      box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
      width: 90%;
      max-width: 800px;
      max-height: 80vh;
      display: flex;
      flex-direction: column;
    }
    .story-dex-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 20px;
      border-bottom: 1px solid var(--line);
    }
    .story-dex-header h2 {
      margin: 0;
      font-size: 18px;
      font-weight: 600;
    }
    .story-dex-close {
      background: none;
      border: none;
      font-size: 24px;
      cursor: pointer;
      padding: 0;
      width: 30px;
      height: 30px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 6px;
    }
    .story-dex-close:hover {
      background: var(--muted);
    }
    .story-dex-body {
      padding: 20px;
      overflow-y: auto;
      flex: 1;
    }
    .story-dex-controls {
      margin-bottom: 20px;
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }
    .add-dex-entry, .export-dex, .import-dex {
      position: sticky;
      top: 0;
      background: #007bff;
      color: white;
      border: none;
      padding: 8px 16px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 14px;
      box-shadow: 0 2px 4px rgba(0, 123, 255, 0.3);
      z-index: 10;
    }
    .add-dex-entry:hover, .export-dex:hover, .import-dex:hover {
      background: #0056b3;
    }
    .export-dex {
      background: #28a745;
      box-shadow: 0 2px 4px rgba(40, 167, 69, 0.3);
    }
    .export-dex:hover {
      background: #1e7e34;
    }
    .import-dex {
      background: #6c757d;
      box-shadow: 0 2px 4px rgba(108, 117, 125, 0.3);
    }
    .import-dex:hover {
      background: #545b62;
    }
    .story-dex-entries {
      display: flex;
      flex-direction: column;
      gap: 15px;
    }
    
    /* Two-column layout on desktop */
    @media (min-width: 768px) {
      .story-dex-entries {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 15px;
      }
    }
    .dex-entry {
      background: var(--muted);
      border: 1px solid var(--line);
      border-radius: 8px;
      padding: 15px;
    }
    .dex-entry-header {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      gap: 10px;
      margin-bottom: 8px;
    }
    .remove-dex-entry:hover {
      background: #c82333 !important;
    }
    .dex-entry-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
    }
    .dex-entry-name {
      width: 100%;
      border: 1px solid var(--line);
      border-radius: 4px;
      padding: 6px 8px;
      font-size: 14px;
      font-weight: 600;
      background: var(--bg);
      color: var(--ink);
    }
    .remove-dex-entry {
      background: #dc3545;
      color: white;
      border: none;
      padding: 4px 8px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 12px;
      margin-left: 10px;
    }
    .remove-dex-entry:hover {
      background: #c82333;
    }
    .dex-entry-description {
      width: 100%;
      border: 1px solid var(--line);
      border-radius: 4px;
      padding: 8px;
      margin-bottom: 10px;
      min-height: 100px;
      resize: vertical;
      font-family: inherit;
      font-size: 14px;
      background: var(--bg);
      color: var(--ink);
    }
    .dex-entry-keywords {
      width: 100%;
      border: 1px solid var(--line);
      border-radius: 4px;
      padding: 6px 8px;
      font-size: 14px;
      background: var(--bg);
      color: var(--ink);
    }
    .dex-entry label {
      display: block;
      margin-bottom: 4px;
      font-size: 12px;
      color: var(--sub);
      font-weight: 500;
    }

    /* ========================= */
    /* Preview Input Modal */
    /* ========================= */
    .preview-input-modal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 1000;
      display: none;
    }
    .preview-input-modal[data-open="1"] {
      display: block;
    }
    .preview-input-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.5);
    }
    .preview-input-content {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: #fff;
      border-radius: 12px;
      box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
      width: 90%;
      max-width: 800px;
      max-height: 80vh;
      display: flex;
      flex-direction: column;
    }
    .preview-input-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 20px;
      border-bottom: 1px solid var(--line);
    }
    .preview-input-header h2 {
      margin: 0;
      font-size: 18px;
      font-weight: 600;
    }
    .preview-input-close {
      background: none;
      border: none;
      font-size: 24px;
      cursor: pointer;
      width: 32px;
      height: 32px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 6px;
      color: var(--sub);
    }
    .preview-input-close:hover {
      background: var(--muted);
      color: var(--ink);
    }
    .preview-input-body {
      padding: 20px;
      overflow-y: auto;
      flex: 1;
    }
    .preview-input-info {
      margin-bottom: 15px;
      font-size: 14px;
      color: var(--sub);
      padding: 12px;
      background: var(--muted);
      border-radius: 6px;
    }
    .preview-input-text {
      background: #f8f9fa;
      border: 1px solid var(--line);
      border-radius: 8px;
      padding: 16px;
      font-family: 'SF Mono', Monaco, 'Cascadia Code', 'Roboto Mono', Consolas, 'Courier New', monospace;
      font-size: 13px;
      line-height: 1.5;
      white-space: pre-wrap;
      word-wrap: break-word;
      max-height: 50vh;
      overflow-y: auto;
    }


      }
      .page-progress {
        order: 3;
        flex-basis: 100%;
        margin: 8px 0 0 0;
        max-width: none;
      }
    }

    /* ========================= */
    /* New Footer Design */
    /* ========================= */
    #app-footer {
      background: var(--muted);
      border-top: 1px solid var(--line);
      padding: 0;
      display: flex;
      flex-direction: column;
      gap: 0;
      position: relative;
      z-index: 10;
    }

    #footer-console {
      padding: 10px 14px;
      font-size: 12px;
      color: var(--sub);
      display: flex;
      gap: 10px;
      align-items: center;
      border-bottom: 1px solid var(--line);
    }
    
    /* Mobile footer console improvements */
    @media (max-width: 768px) {
      #footer-console {
        height: 36px; /* Fixed single line height */
        overflow-x: auto;
        overflow-y: hidden;
        white-space: nowrap;
        padding: 8px 14px;
        scrollbar-width: thin;
      }
      
      #footer-console::-webkit-scrollbar {
        height: 4px;
      }
      
      #footer-console::-webkit-scrollbar-track {
        background: var(--muted);
      }
      
      #footer-console::-webkit-scrollbar-thumb {
        background: var(--line);
        border-radius: 2px;
      }
      
      /* Add bottom spacing to editor on mobile to prevent AI button overlap */
      #editor {
        padding-bottom: 60px;
      }
      
      /* Hide controls when mobile settings are enabled */
      body[data-hide-markdown-controls="true"] #formatting-row {
        display: none;
      }
      
      body[data-hide-footer-console="true"] #footer-console {
        display: none;
      }
    }

    #footer-pagination {
      padding: 12px 16px;
      background: var(--muted);
      border-top: 1px solid var(--line);
    }

    /* Pagination Controls */
    .pagination-nav {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 12px;
      margin-bottom: 8px;
    }

    .pagination-nav button {
      padding: 6px 12px;
      border: 1px solid var(--line);
      background: var(--bg);
      color: var(--ink);
      border-radius: 6px;
      cursor: pointer;
      font-size: 12px;
    }

    .pagination-nav button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .pagination-nav button:hover:not(:disabled) {
      background: var(--line);
    }

    #page-info {
      font-weight: 500;
      color: var(--ink);
      background: transparent;
      border: none;
      padding: 4px 8px;
      border-radius: 4px;
      cursor: pointer;
      transition: background-color 200ms ease;
    }
    
    #page-info:hover {
      background: var(--line);
    }
    
    #page-info:active {
      background: var(--muted);
    }

    .pagination-progress {
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .page-progress-bar {
      flex: 1;
      height: 4px;
      background: var(--line);
      border-radius: 2px;
      overflow: hidden;
    }

    .page-progress-fill {
      height: 100%;
      background: #4a90e2;
      border-radius: 2px;
      transition: width 200ms ease;
    }

    #page-details {
      color: var(--sub);
      font-size: 11px;
      min-width: 80px;
      text-align: right;
    }

    /* Mobile footer adjustments */
    @media (max-width: 768px) {
      #footer-pagination {
        padding: 10px 12px;
      }

      .pagination-nav {
        flex-direction: row;
        justify-content: center;
        align-items: center;
        gap: 12px;
        margin-bottom: 8px;
      }

      .pagination-nav button {
        flex: 0 0 auto;
        min-width: 70px;
        padding: 6px 8px;
        font-size: 12px;
      }

      #page-info {
        flex: 0 0 auto;
        text-align: center;
        font-size: 12px;
        min-width: 0;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        background: transparent;
        border: none;
        padding: 6px 8px;
      }
    }
  </style>
</head>
<body data-mode="edit">
<div class="app">
  <header>
    <div class="toolbar">
      <div class="row">
        <button id="auth-btn">Sign in</button>
        <button id="file-btn" disabled>File</button>
        <button id="export-story-btn" title="Export story in different formats">Export Story</button>
      </div>
      <div class="row" id="formatting-row" title="Formatting inserts Markdown/HTML into the plaintext">
        <button id="bold-btn" aria-label="Bold (Ctrl/⌘+B)"><strong>B</strong></button>
        <button id="italic-btn" aria-label="Italic (Ctrl/⌘+I)"><em>I</em></button>
        <button id="underline-btn" aria-label="Underline (Ctrl/⌘+U)"><u>U</u></button>
        <button id="hidden-btn" aria-label="Hidden text (Ctrl/⌘+H)">[H]</button>
        <button id="bullet-btn" aria-label="Bulleted list (Ctrl/⌘+Shift+8)">• List</button>
        <button id="header-btn" aria-label="Add header to selection" class="pill" style="background:#fff;border:1px solid var(--line)">Hdr</button>
        <select id="heading-select" aria-label="Heading">
          <option value="0">Paragraph</option>
          <option value="1">H1</option>
          <option value="2">H2</option>
          <option value="3">H3</option>
          <option value="4">H4</option>
          <option value="5">H5</option>
          <option value="6">H6</option>
        </select>
        <button id="toggle-preview">Preview</button>
        <button id="toggle-split">Split</button>
      </div>
    </div>
    <div id="list-panel">
      <table>
        <thead><tr><th style="width:45%">Name</th><th style="width:35%">Modified</th><th style="width:20%">Actions</th></tr></thead>
        <tbody id="list-body"></tbody>
      </table>
    </div>
  </header>

  <main class="main">
    <div id="editor-wrap">
      <textarea id="editor" placeholder="Write your story here…"></textarea>
    </div>
    <div id="preview" aria-live="polite"></div>
  </main>

  <!-- New Footer with Console and Pagination -->
  <footer id="app-footer">
    <div id="footer-console">
      <span id="status">Ready.</span>
      <span id="active-file"></span>
      <span class="dot idle" id="save-indicator" title="Save status"></span>
      <span class="pill" id="sync-note"></span>
    </div>
    
    <!-- Pagination Controls in Footer -->
    <div id="footer-pagination" style="display: none;">
      <div class="pagination-nav">
        <button id="prev-page-btn" disabled>← Previous</button>
        <button id="page-info" title="Click to jump to page">Page 1 of 1</button>
        <button id="next-page-btn" disabled>Next →</button>
      </div>
      <div class="pagination-progress">
        <div class="page-progress-bar">
          <div class="page-progress-fill" style="width: 100%"></div>
        </div>
        <span id="page-details">0 characters</span>
      </div>
</div>

<!-- Side tab and drawer -->
<button id="meta-tab" aria-expanded="false" aria-controls="meta-panel" title="Settings (Alt+M)">Settings</button>
<div id="meta-scrim" aria-hidden="true"></div>

<!-- Fixed Generate Button -->
<button id="fixed-generate-btn" title="Generate AI content (Ctrl/⌘+G)">Generate with AI</button>
<button id="cancel-generate-btn" title="Cancel generation">Cancel</button>
<button id="undo-generate-btn" title="Undo last AI generation">Undo Generation</button>
<aside id="meta-panel" role="complementary" aria-label="Story metadata" data-open="0">
  <div id="meta-head">
    <div id="meta-title">Settings</div>
    <div style="display:flex; gap:6px; align-items:center;">
      <button id="meta-save-now" title="Save now (Ctrl/⌘+S)">Save</button>
      <button id="meta-close" title="Close (Esc)">Close</button>
    </div>
  </div>
  
  <!-- Tab Navigation -->
  <div id="meta-tabs">
    <button class="meta-tab-btn active" data-tab="story">Story Settings</button>
    <button class="meta-tab-btn" data-tab="ai">AI Settings</button>
    <button class="meta-tab-btn" data-tab="display">Display</button>
  </div>
  
  <div id="meta-body">
    <!-- Story Settings Tab -->
    <div id="story-tab" class="tab-content active">
      <div class="row">
        <label for="ai-pre">AI Pre‑prompt</label>
        <textarea id="ai-pre" placeholder="System-style guidance for the model…"></textarea>
      </div>
      <div class="row">
        <label for="next-inst">Next Instructions</label>
        <textarea id="next-inst" placeholder="Steering for the next generation…"></textarea>
        <div id="next-enable-wrap">
          <label style="display:flex;align-items:center;gap:6px;"><input type="checkbox" id="next-enabled" /> Enable</label>
        </div>
      </div>
      <div class="row">
        <label>Story Dex</label>
        <button id="story-dex-btn" style="padding: 8px 12px; border: 1px solid var(--line); background: #fff; border-radius: 8px; cursor: pointer;">Open Story Dex</button>
      </div>
    </div>
    
    <!-- AI Settings Tab -->
    <div id="ai-tab" class="tab-content">
      <div class="row">
        <label for="openrouter-key">OpenRouter API Key</label>
        <input type="password" id="openrouter-key" placeholder="sk-or-v1-..." title="Get your API key from https://openrouter.ai/" />
        <div style="display:flex;align-items:center;gap:6px;margin-top:4px;">
          <label style="display:flex;align-items:center;gap:6px;"><input type="checkbox" id="remember-key" /> Remember API key</label>
        </div>
      </div>
      <div class="row">
        <label for="ai-model">AI Model</label>
        <div style="position: relative;">
          <input type="text" id="ai-model" placeholder="Search for a model..." title="Search and select AI model" />
          <div id="model-dropdown" style="display: none; position: absolute; top: 100%; left: 0; right: 0; background: white; border: 1px solid var(--line); border-top: none; border-radius: 0 0 8px 8px; max-height: 200px; overflow-y: auto; z-index: 1000;"></div>
        </div>
      </div>
      <div class="row">
        <label for="max-output-tokens">Max Output Tokens</label>
        <input type="number" id="max-output-tokens" min="1" max="4000" value="1000" />
      </div>
      <div class="row">
        <label for="max-input-characters">Max Input Characters</label>
        <input type="number" id="max-input-characters" min="1" max="128000" value="32000" />
      </div>
      <div class="row">
        <label for="temperature">Temperature</label>
        <input type="range" id="temperature" min="0" max="2" step="0.1" value="0.7" />
        <span class="range-value">0.7</span>
      </div>
      <div class="row">
        <label for="top-p">Top P</label>
        <input type="range" id="top-p" min="0" max="1" step="0.05" value="1" />
        <span class="range-value">1.0</span>
      </div>
      <div class="row">
        <label for="top-k">Top K</label>
        <input type="number" id="top-k" min="1" max="100" value="0" placeholder="0 = disabled" />
      </div>
      <div class="row">
        <label>
          <input type="checkbox" id="clean-ai-output" checked />
          Clean AI Output
        </label>
      </div>
      <div class="row">
        <label>Estimated Cost</label>
        <div id="cost-estimate" class="pill" style="background:#e8f4fd;border:1px solid #bee5eb;">~$0.00 per generation</div>
      </div>
      <div class="row" style="margin-top:20px;padding-top:20px;border-top:1px solid var(--line);">
        <button id="preview-input-btn" style="width:100%;padding:10px;background:#f8f9fa;border:1px solid var(--line);border-radius:8px;cursor:pointer;margin-bottom:15px;">
          Preview Input
        </button>
        <div style="font-size:12px;color:#666;text-align:center;">
          Use the blue "Generate with AI" button at the bottom-right corner to generate content.
        </div>
      </div>
    </div>
    
    <!-- Display Settings Tab -->
    <div id="display-tab" class="tab-content">
      <div class="row">
        <label>Theme</label>
        <select id="theme-select">
          <option value="light">Light</option>
          <option value="dark">Dark</option>
        </select>
      </div>
      <div class="row">
        <label>Editor Font Family</label>
        <select id="editor-font-family">
          <option value="mono">Monospace (Default)</option>
          <option value="serif">Serif</option>
          <option value="sans-serif">Sans Serif</option>
        </select>
      </div>
      <div class="row" id="desktop-font-row">
        <label>Editor Font Size (Desktop)</label>
        <input type="range" id="font-size-desktop" min="12" max="24" step="1" value="14" />
        <span class="range-value">14px</span>
      </div>
      <div class="row" id="mobile-font-row" style="display: none;">
        <label>Editor Font Size (Mobile)</label>
        <input type="range" id="font-size-mobile" min="12" max="20" step="1" value="14" />
        <span class="range-value">14px</span>
      </div>

      <!-- Pagination Settings -->
      <div class="row">
        <label>
          <input type="checkbox" id="pagination-enabled" />
          Enable Pagination
        </label>
      </div>
      <div class="row" id="desktop-page-size-row">
        <label>Page Size - Desktop (characters)</label>
        <input type="range" id="page-size-desktop" min="5000" max="50000" step="1000" value="20000" />
        <span class="range-value">20000</span>
      </div>
      <div class="row" id="mobile-page-size-row" style="display: none;">
        <label>Page Size - Mobile (characters)</label>
        <input type="range" id="page-size-mobile" min="2000" max="20000" step="500" value="10000" />
        <span class="range-value">10000</span>
      </div>

      <!-- Mobile-specific UI Settings -->
      <div class="row" id="mobile-ui-settings" style="display: none;">
        <h4 style="margin: 16px 0 8px 0; font-size: 14px; color: var(--ink);">Mobile Interface</h4>
        <label style="display: block; margin-bottom: 8px;">
          <input type="checkbox" id="hide-markdown-controls" />
          Hide Markdown Controls
        </label>
        <label style="display: block;">
          <input type="checkbox" id="hide-footer-console" />
          Hide Footer Console
        </label>
      </div>

    </div>
  </div>
  <div id="meta-foot">
    <div>Changes autosave with content. <span class="pill">Alt+M</span> toggles. <span class="pill">Ctrl/⌘+G</span> generates AI.</div>
    <div id="meta-hint" class="pill" style="background:#fff;border:1px solid var(--line)">Drive‑synced</div>
  </div>
</aside>

<!-- Story Dex Modal -->
<div id="story-dex-modal" class="story-dex-modal" data-open="0">
  <div class="story-dex-overlay"></div>
  <div class="story-dex-content">
    <div class="story-dex-header">
      <h2>Story Dex</h2>
      <button id="story-dex-close" class="story-dex-close">&times;</button>
    </div>
    <div class="story-dex-body">
      <div class="story-dex-controls">
        <button id="add-dex-entry" class="add-dex-entry">+ Add Entry</button>
        <button id="export-dex" class="export-dex">Export</button>
        <button id="import-dex" class="import-dex">Import</button>
        <input type="file" id="import-dex-file" accept=".json" style="display: none;" />
      </div>
      <div id="story-dex-entries" class="story-dex-entries">
        <!-- Entries will be populated here -->
      </div>
    </div>
  </div>
</div>

<!-- Preview Input Modal -->
<div id="preview-input-modal" class="preview-input-modal" data-open="0">
  <div class="preview-input-overlay"></div>
  <div class="preview-input-content">
    <div class="preview-input-header">
      <h2>AI Input Preview</h2>
      <button id="preview-input-close" class="preview-input-close">&times;</button>
    </div>
    <div class="preview-input-body">
      <div class="preview-input-info">
        This is the exact text that would be sent to the AI model:
      </div>
      <div id="preview-input-text" class="preview-input-text">
        <!-- Preview text will be populated here -->
      </div>
    </div>
  </div>
</div>

<!-- Export Story Modal -->
<div id="export-story-modal" class="story-dex-modal" data-open="0">
  <div class="story-dex-overlay"></div>
  <div class="story-dex-content">
    <div class="story-dex-header">
      <h2>Export Story</h2>
      <button id="export-story-close" class="story-dex-close">&times;</button>
    </div>
    <div class="story-dex-body">
      <div style="padding: 20px;">
        <p>Choose export format:</p>
        <div style="margin: 20px 0; display: flex; flex-direction: column; gap: 12px;">
          <button id="export-markdown-btn" style="padding: 12px; border: 1px solid var(--line); background: var(--bg); border-radius: 8px; cursor: pointer; text-align: left;">
            <strong>Markdown (.txt)</strong><br>
            <span style="color: var(--sub); font-size: 13px;">Exports with all markdown formatting preserved</span>
          </button>
          <button id="export-richtext-btn" style="padding: 12px; border: 1px solid var(--line); background: var(--bg); border-radius: 8px; cursor: pointer; text-align: left;">
            <strong>Rich Text (.txt)</strong><br>
            <span style="color: var(--sub); font-size: 13px;">Exports with hidden text (in square brackets) removed</span>
          </button>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- File Modal -->
<div id="file-modal" data-open="0">
  <div id="file-modal-content">
    <div id="file-modal-header">
      <div id="file-modal-title">File Operations</div>
      <button id="file-modal-close">&times;</button>
    </div>
    <div id="file-modal-body">
      <div class="file-action">
        <button id="modal-new-btn" disabled>New Document</button>
        <button id="modal-save-as-btn" disabled>Save As</button>
      </div>
      <div id="file-list-section">
        <h3>My Files</h3>
        <div id="modal-file-list">
          <table style="width: 100%; border-collapse: collapse; font-size: 13px;">
            <thead>
              <tr style="background: var(--muted);">
                <th style="padding: 8px 12px; border-bottom: 1px solid var(--line); text-align: left;">Name</th>
                <th style="padding: 8px 12px; border-bottom: 1px solid var(--line); text-align: left;">Modified</th>
                <th style="padding: 8px 12px; border-bottom: 1px solid var(--line); text-align: left;">Actions</th>
              </tr>
            </thead>
            <tbody id="modal-list-body">
              <!-- Files will be populated here -->
            </tbody>
          </table>
        </div>
      </div>
    </div>
  </div>
</div>

<script>
  // =========================
  //  Configuration
  // =========================
  const CLIENT_ID = "389780383024-03s13biqo3n1hvdv2mn8jb2fcvc17ks3.apps.googleusercontent.com"; // OAuth 2.0 Web client ID (public)
  const SCOPE = "https://www.googleapis.com/auth/drive.file https://www.googleapis.com/auth/drive.appdata"; // Drive scope + app data

  const DRIVE_UPLOAD_URL = "https://www.googleapis.com/upload/drive/v3/files";
  const DRIVE_FILES_URL  = "https://www.googleapis.com/drive/v3/files";
  
  // AI Settings
  const AI_SETTINGS_FILENAME = "ghostwriter-ai-settings.json";

  // Autosave + polling
  const AUTOSAVE_DELAY = 1200;  // ms after last keystroke
  const POLL_INTERVAL  = 8000;  // ms between remote checks
  const IDLE_GRACE     = 1200;  // ms considered "still typing"

  // File format sentinels for JSON header
  const META_START = ";;;GW:JSON-START";
  const META_END   = ";;;GW:JSON-END";

  const DEFAULT_META = {
    ai_pre_prompt: "",
    next_instructions: "",
    next_instructions_enabled: false,
    openrouter_key: "",
    remember_key: false,
    ai_model: "",
    max_tokens: 1000,
    max_input_characters: 8000,
    temperature: 0.7,
    top_p: 1.0,
    top_k: 0,
    story_dex: []
  };

  // =========================
  //  DOM
  // =========================
  const authBtn      = document.getElementById("auth-btn");
  const fileBtn      = document.getElementById("file-btn");
  const editor = document.getElementById("editor");
  const statusEl = document.getElementById("status");
  const activeFileEl = document.getElementById("active-file");
  const saveDot      = document.getElementById("save-indicator");
  const syncNote     = document.getElementById("sync-note");
  
  // File modal elements
  const fileModal = document.getElementById("file-modal");
  const fileModalClose = document.getElementById("file-modal-close");
  const modalNewBtn = document.getElementById("modal-new-btn");
  const modalSaveAsBtn = document.getElementById("modal-save-as-btn");
  const modalListBody = document.getElementById("modal-list-body");
  
  // Formatting controls
  const boldBtn      = document.getElementById("bold-btn");
  const italicBtn    = document.getElementById("italic-btn");
  const underlineBtn = document.getElementById("underline-btn");
  const hiddenBtn    = document.getElementById("hidden-btn");
  const bulletBtn    = document.getElementById("bullet-btn");
  const headerBtn    = document.getElementById("header-btn");
  const headingSel   = document.getElementById("heading-select");
  const togglePreviewBtn = document.getElementById("toggle-preview");
  const toggleSplitBtn   = document.getElementById("toggle-split");
  const previewEl    = document.getElementById("preview");

  // Side panel elements
  const metaPanel    = document.getElementById("meta-panel");
  const metaScrim    = document.getElementById("meta-scrim");
  const metaTab      = document.getElementById("meta-tab");
  const metaClose    = document.getElementById("meta-close");
  const metaSaveNow  = document.getElementById("meta-save-now");

  const aiPreInput   = document.getElementById("ai-pre");
  const nextInstInput= document.getElementById("next-inst");
  const nextEnabled  = document.getElementById("next-enabled");
  
  // Display settings elements
  const themeSelect     = document.getElementById("theme-select");
  const fontFamilySelect= document.getElementById("editor-font-family");
  const fontSizeDesktop = document.getElementById("font-size-desktop");
  const fontSizeMobile  = document.getElementById("font-size-mobile");
  const desktopFontRow  = document.getElementById("desktop-font-row");
  const mobileFontRow   = document.getElementById("mobile-font-row");
  
  // Pagination elements
  const paginationEnabledCheckbox = document.getElementById("pagination-enabled");
  const pageSizeDesktop = document.getElementById("page-size-desktop");
  const pageSizeMobile = document.getElementById("page-size-mobile");
  const desktopPageSizeRow = document.getElementById("desktop-page-size-row");
  const mobilePageSizeRow = document.getElementById("mobile-page-size-row");
  const paginationControls = document.getElementById("footer-pagination");
  const prevPageBtn = document.getElementById("prev-page-btn");
  const nextPageBtn = document.getElementById("next-page-btn");
  const pageInfo = document.getElementById("page-info");
  const pageDetails = document.getElementById("page-details");
  const pageProgressFill = document.querySelector(".page-progress-fill");
  
  // Mobile UI settings
  const mobileUiSettings = document.getElementById("mobile-ui-settings");
  const hideMarkdownControls = document.getElementById("hide-markdown-controls");
  const hideFooterConsole = document.getElementById("hide-footer-console");
  

  
  // Story Dex elements
  const storyDexBtn = document.getElementById("story-dex-btn");
  const storyDexModal = document.getElementById("story-dex-modal");
  const storyDexClose = document.getElementById("story-dex-close");
  const addDexEntryBtn = document.getElementById("add-dex-entry");
  const exportDexBtn = document.getElementById("export-dex");
  const importDexBtn = document.getElementById("import-dex");
  const importDexFile = document.getElementById("import-dex-file");
  const storyDexEntries = document.getElementById("story-dex-entries");
  
  const previewInputBtn = document.getElementById("preview-input-btn");
  const previewInputModal = document.getElementById("preview-input-modal");
  const previewInputClose = document.getElementById("preview-input-close");
  const previewInputText = document.getElementById("preview-input-text");
  
  // Export Story elements
  const exportStoryBtn = document.getElementById("export-story-btn");
  const exportStoryModal = document.getElementById("export-story-modal");
  const exportStoryClose = document.getElementById("export-story-close");
  const exportMarkdownBtn = document.getElementById("export-markdown-btn");
  const exportRichTextBtn = document.getElementById("export-richtext-btn");
  
  const openrouterKey = document.getElementById("openrouter-key");
  const rememberKey  = document.getElementById("remember-key");
  const aiModel      = document.getElementById("ai-model");
  const modelDropdown = document.getElementById("model-dropdown");

  const fixedGenerateBtn = document.getElementById("fixed-generate-btn");
  const cancelGenerateBtn = document.getElementById("cancel-generate-btn");
  const undoGenerateBtn = document.getElementById("undo-generate-btn");
  const maxOutputTokensInput = document.getElementById("max-output-tokens");
  const maxInputCharactersInput = document.getElementById("max-input-characters");
  const temperatureInput = document.getElementById("temperature");
  const topPInput = document.getElementById("top-p");
  const topKInput = document.getElementById("top-k");
  const cleanAIOutput = document.getElementById("clean-ai-output");
  const costEstimate = document.getElementById("cost-estimate");

  // =========================
  //  Auth & state
  // =========================
  let tokenClient = null;
  let accessToken = null; // kept in-memory only
  let currentFileId = null;
  let currentFileName = null;
  let autosaveTimer = null;
  let pollTimer = null;
  let isSaving = false;
  let dirty = false;           // local edits (editor or metadata) since last save
  let lastInputTs = 0;         // timestamp of last edit
  let lastRemoteModified = 0;  // ms
  
  // AI Settings state
  let aiSettingsFileId = null; // ID of the AI settings file in appdata folder
  let aiSettingsLoaded = false; // whether we've attempted to load AI settings
  let saveAISettingsTimer = null; // timer for delayed AI settings save
  
  // Auth refresh state
  let isRefreshingToken = false; // flag to prevent concurrent refresh attempts
  let allowBackgroundRefresh = false; // whether background operations can trigger auth popups
  
  // Generation state
  let isGenerating = false;
  let generationController = null; // AbortController for canceling requests
  let isCtrlHeld = false; // Track if CTRL key is being held
  
  // Undo generation state
  let lastContentBeforeGeneration = null; // Content before last generation
  let hasUndoableGeneration = false; // Whether there's a generation that can be undone
  let contentChangedSinceGeneration = false; // Whether user has edited since generation
  

  
  // Current active tab
  let activeTab = 'story';
  
  // Story Dex state
  let currentStoryDex = [];
  
  // Pagination state
  let paginationEnabled = false;
  let currentPageIndex = 0;
  let pages = [];
  let fullContent = '';
  let isEditingPage = false; // Flag to prevent repagination while editing
  
  // Available models from OpenRouter
  let availableModels = [
    // Default models to show even without API key
    { id: 'anthropic/claude-3.5-sonnet', name: 'Claude 3.5 Sonnet', pricing: 0.000015, displayText: 'anthropic/claude-3.5-sonnet - $0.000015/1K tokens' },
    { id: 'anthropic/claude-3-haiku', name: 'Claude 3 Haiku', pricing: 0.00000025, displayText: 'anthropic/claude-3-haiku - $0.000000/1K tokens' },
    { id: 'openai/gpt-4o', name: 'GPT-4o', pricing: 0.00001, displayText: 'openai/gpt-4o - $0.000010/1K tokens' },
    { id: 'openai/gpt-4o-mini', name: 'GPT-4o Mini', pricing: 0.00000015, displayText: 'openai/gpt-4o-mini - $0.000000/1K tokens' },
    { id: 'meta-llama/llama-3.1-70b-instruct', name: 'Llama 3.1 70B', pricing: 0.0000009, displayText: 'meta-llama/llama-3.1-70b-instruct - $0.000001/1K tokens' },
    { id: 'meta-llama/llama-3.1-8b-instruct', name: 'Llama 3.1 8B', pricing: 0.00000006, displayText: 'meta-llama/llama-3.1-8b-instruct - $0.000000/1K tokens' }
  ];

  // Model loading retry state
  let modelLoadAttempts = 0;
  let modelLoadRetryTimer = null;
  let maxModelLoadAttempts = 3;

  function setStatus(msg) { statusEl.textContent = msg; }
  function setSaveDot(state) {
    saveDot.classList.remove("saving","saved","idle");
    saveDot.classList.add(state);
  }
  function setActiveFile(id, name) {
    currentFileId = id || null;
    currentFileName = name || null;
    activeFileEl.textContent = id ? `• File: ${name || "(untitled)"} — ID: ${id}` : "";
  }
  
  function updateAuthButton(signedIn) {
    if (signedIn) {
      authBtn.textContent = "Sign out";
      authBtn.title = "Sign out of Google Drive";
    } else {
      authBtn.textContent = "Sign in";
      authBtn.title = "Sign in to Google Drive";
    }
  }
  
  function setSignedInUI(signedIn) {
    updateAuthButton(signedIn);
    fileBtn.disabled = !signedIn;
    modalSaveAsBtn.disabled = !signedIn;
    modalNewBtn.disabled = !signedIn;
    editor.disabled = !signedIn; // Block typing while logged out
    [boldBtn, italicBtn, underlineBtn, hiddenBtn, bulletBtn, headerBtn, headingSel, togglePreviewBtn, toggleSplitBtn, nextInstInput, nextEnabled, metaClose, metaSaveNow].forEach(el => el.disabled = !signedIn);
    // Generate button and AI pre-prompt should work independently of Google authentication
    // Their state is managed by updateGenerateButton() based on API key and model
    // Keep Settings accessible so users can configure AI settings without Google login
    metaTab.setAttribute('aria-disabled', String(false)); // Always allow access to settings
    if (!signedIn) openMeta(false);
  }
  
  // File modal functions
  function openFileModal() {
    fileModal.setAttribute('data-open', '1');
    refreshModalFileList();
  }
  
  function closeFileModal() {
    fileModal.setAttribute('data-open', '0');
  }
  
  async function refreshModalFileList() {
    if (!accessToken) return;
    try {
      const files = await listGhostwriterFiles(true);
      
      modalListBody.innerHTML = files?.map(f => {
        const when = new Date(f.modifiedTime).toLocaleDateString();
        const openHere = `<button data-open="${f.id}" style="padding:2px 6px;font-size:11px;">Open</button>`;
        const rename = `<button data-rename="${f.id}" style="padding:2px 6px;font-size:11px;">Rename</button>`;
        const link = `https://drive.google.com/file/d/${f.id}`;
        return `<tr style="border-bottom: 1px solid var(--line);"><td style="padding: 8px 12px;">${escapeHtml(f.name)}</td><td style="padding: 8px 12px;">${when}</td><td style="padding: 8px 12px;">${openHere} ${rename} <a href="${link}" target="_blank" rel="noreferrer">Drive</a></td></tr>`; 
      }).join("") || '<tr><td colspan="3" style="padding: 20px; text-align: center; color: var(--sub);">No files found</td></tr>';
      
      // Wire up event handlers for the new buttons
      modalListBody.querySelectorAll("button[data-open]").forEach(btn => { 
        btn.addEventListener("click", () => {
          loadFile(btn.getAttribute("data-open"));
          closeFileModal();
        }); 
      }); 
      modalListBody.querySelectorAll("button[data-rename]").forEach(btn => { 
        btn.addEventListener("click", () => promptRenameFile(btn.getAttribute("data-rename"))); 
      }); 
    } catch (e) { 
      console.error(e); 
      setStatus("Failed to load file list. See console."); 
    }
  }
  
  // Mobile settings functions
  function checkMobileSettings() {
    const isMobile = window.innerWidth <= 768;
    
    // Show/hide mobile-specific settings
    if (mobileUiSettings) {
      mobileUiSettings.style.display = isMobile ? 'block' : 'none';
    }
    if (mobileFontRow) {
      mobileFontRow.style.display = isMobile ? 'block' : 'none';
    }
    if (desktopFontRow) {
      desktopFontRow.style.display = isMobile ? 'none' : 'block';
    }
    if (mobilePageSizeRow) {
      mobilePageSizeRow.style.display = isMobile ? 'block' : 'none';
    }
    if (desktopPageSizeRow) {
      desktopPageSizeRow.style.display = isMobile ? 'none' : 'block';
    }
  }
  
  function applyMobileSettings() {
    if (hideMarkdownControls && hideMarkdownControls.checked) {
      document.body.setAttribute('data-hide-markdown-controls', 'true');
    } else {
      document.body.removeAttribute('data-hide-markdown-controls');
    }
    
    if (hideFooterConsole && hideFooterConsole.checked) {
      document.body.setAttribute('data-hide-footer-console', 'true');
    } else {
      document.body.removeAttribute('data-hide-footer-console');
    }
  }
  
  function loadMobileSettings() {
    if (hideMarkdownControls) {
      const saved = localStorage.getItem('ghostwriter_hide_markdown_controls');
      hideMarkdownControls.checked = saved === 'true';
    }
    if (hideFooterConsole) {
      const saved = localStorage.getItem('ghostwriter_hide_footer_console');
      hideFooterConsole.checked = saved === 'true';
    }
    applyMobileSettings();
  }
  
  function saveMobileSettings() {
    if (hideMarkdownControls) {
      localStorage.setItem('ghostwriter_hide_markdown_controls', hideMarkdownControls.checked);
    }
    if (hideFooterConsole) {
      localStorage.setItem('ghostwriter_hide_footer_console', hideFooterConsole.checked);
    }
    applyMobileSettings();
  }
  
  function getQueryFileId() { const p = new URLSearchParams(location.search); return p.get("file"); }

  window.addEventListener("load", () => {
    // Initialize UI as disabled first
    setSignedInUI(false);
    
    const waitFor = (cond, timeout = 10000) => new Promise((resolve, reject) => { 
      const start = Date.now();
      const t = () => {
        if (cond()) {
          resolve();
        } else if (Date.now() - start > timeout) {
          reject(new Error('Timeout waiting for condition'));
        } else {
          setTimeout(t, 50);
        }
      };
      t();
    });
    waitFor(() => window.google && google.accounts && google.accounts.oauth2).then(() => {
      tokenClient = google.accounts.oauth2.initTokenClient({
        client_id: CLIENT_ID,
        scope: SCOPE,
        callback: (resp) => {
          if (resp.error) { console.error(resp); setStatus("Auth error."); return; }
          accessToken = resp.access_token;
          setCookie('ghostwriter_auth', accessToken, 1); // Save for 1 day
          setStatus("Signed in.");
          setSignedInUI(true);
          loadAISettings(); // Load saved AI settings after authentication
          const preset = getQueryFileId();
          if (preset) { 
            loadFile(preset); 
          } else {
            // No file to load, set default pre-prompt for new session
            aiPreInput.value = getDefaultAIPrePrompt();
          }
        }
      });
      wireEvents();
      
      // Initialize mobile settings
      checkMobileSettings();
      loadMobileSettings();
      
      // Check for saved authentication
      const savedAuth = getCookie('ghostwriter_auth');
      if (savedAuth) {
        accessToken = savedAuth;
        setStatus("Restoring session...");
        setSignedInUI(true);
        loadAISettings();
        const preset = getQueryFileId();
        if (preset) { 
          loadFile(preset); 
        } else {
          // No file to load, set default pre-prompt for new session
          aiPreInput.value = getDefaultAIPrePrompt();
        }
      } else {
        setStatus("Ready. Sign in to begin.");
        setSignedInUI(false); // Ensure UI is properly disabled when not signed in
        // Set default pre-prompt even when not signed in
        aiPreInput.value = getDefaultAIPrePrompt();
      }
      
      updateGenerateButton(); // Initialize AI button state
    }).catch(err => { 
      console.error(err); 
      setStatus("Failed to initialize Google Identity Services."); 
      // Ensure UI is properly disabled even if Google services fail to load
      setSignedInUI(false);
      // Set default pre-prompt even when Google services fail
      aiPreInput.value = getDefaultAIPrePrompt();
      // Still need to wire events and initialize mobile settings
      wireEvents();
      checkMobileSettings();
      loadMobileSettings();
      updateGenerateButton();
    });
  });

  function ensureAuth(action, fn) {
    return () => {
      if (!accessToken) {
        setStatus(`Requesting permission for ${action}…`);
        allowBackgroundRefresh = true; // Allow refresh for user actions
        tokenClient.requestAccessToken({ prompt: "consent" });
        return;
      }
      // Enable background refresh for the duration of this user action
      const oldAllowBackgroundRefresh = allowBackgroundRefresh;
      allowBackgroundRefresh = true;
      try {
        fn();
      } finally {
        // Restore previous setting after a short delay
        setTimeout(() => {
          allowBackgroundRefresh = oldAllowBackgroundRefresh;
        }, 5000);
      }
    };
  }

  // Cookie management for auth persistence
  function setCookie(name, value, days = 30) {
    const expires = new Date();
    expires.setTime(expires.getTime() + (days * 24 * 60 * 60 * 1000));
    document.cookie = `${name}=${value};expires=${expires.toUTCString()};path=/;SameSite=Lax`;
  }

  function getCookie(name) {
    const nameEQ = name + "=";
    const ca = document.cookie.split(';');
    for (let i = 0; i < ca.length; i++) {
      let c = ca[i];
      while (c.charAt(0) === ' ') c = c.substring(1, c.length);
      if (c.indexOf(nameEQ) === 0) return c.substring(nameEQ.length, c.length);
    }
    return null;
  }

  function deleteCookie(name) {
    document.cookie = `${name}=;expires=Thu, 01 Jan 1970 00:00:01 GMT;path=/`;
  }

  function wireEvents() {
    // Unified auth button - handles both sign in and sign out
    authBtn.addEventListener("click", () => { 
      if (accessToken) {
        // Sign out
        stopPolling();
        // Clear AI settings state on signout
        aiSettingsLoaded = false;
        aiSettingsFileId = null;
        if (!rememberKey.checked) {
          openrouterKey.value = "";
        }
        updateGenerateButton();
        deleteCookie('ghostwriter_auth');
        google.accounts.oauth2.revoke(accessToken, () => { 
          accessToken = null; 
          setSignedInUI(false); 
          setActiveFile(null, null); 
          setStatus("Signed out."); 
        });
      } else {
        // Sign in
        setStatus("Opening Google sign-in…"); 
        allowBackgroundRefresh = true; // Allow refresh for manual sign-in
        tokenClient.requestAccessToken({ prompt: "consent" }); 
      }
    });

    // File modal
    fileBtn.addEventListener("click", () => openFileModal());
    fileModalClose.addEventListener("click", () => closeFileModal());
    
    // File modal actions
    modalNewBtn.addEventListener("click", ensureAuth("creating a new document", () => {
      newDocument();
      closeFileModal();
    }));
    modalSaveAsBtn.addEventListener("click", ensureAuth("saving file with new name", () => {
      saveAsFile();
      closeFileModal();
    }));
    
    // Close modal when clicking outside
    fileModal.addEventListener("click", (e) => {
      if (e.target === fileModal) closeFileModal();
    });

    // Editor typing => autosave & preview
    editor.addEventListener("input", () => { 
      markDirty(); 
      updatePreview();
      
      // Track changes after AI generation for undo confirmation
      if (hasUndoableGeneration) {
        contentChangedSinceGeneration = true;
      }
      
      // Mark that we're actively editing to prevent repagination
      if (paginationEnabled) {
        isEditingPage = true;
        
        // Update page details in real-time
        const charCount = editor.value.length;
        pageDetails.textContent = `${charCount.toLocaleString()} characters`;
        
        // Throttled full content update
        clearTimeout(window.paginationUpdateTimer);
        window.paginationUpdateTimer = setTimeout(() => {
          if (pages[currentPageIndex]) {
            pages[currentPageIndex].content = editor.value;
            fullContent = rebuildFullContent();
          }
        }, 500);
      }
    });

    // Editor blur => allow repagination when cursor becomes inactive
    editor.addEventListener("blur", () => {
      if (paginationEnabled && isEditingPage) {
        isEditingPage = false;
        // Update current page content
        if (pages[currentPageIndex]) {
          pages[currentPageIndex].content = editor.value;
          fullContent = rebuildFullContent();
        }
        // Trigger pagination recalculation
        initializePagination();
      }
    });

    // Metadata edits => autosave
    aiPreInput.addEventListener("input", () => { markDirty(); });
    nextInstInput.addEventListener("input", () => { markDirty(); });
    nextEnabled.addEventListener("change", () => { markDirty(); });
    openrouterKey.addEventListener("input", () => { 
      markDirty(); 
      updateGenerateButton(); 
      // Save API key after user stops typing (only if remember is checked)
      if (rememberKey.checked) {
        clearTimeout(saveAISettingsTimer);
        saveAISettingsTimer = setTimeout(() => saveAISettings(), 2000);
      }
    });
    rememberKey.addEventListener("change", () => { markDirty(); saveAISettings(); });
    
    // AI Model search functionality
    aiModel.addEventListener("input", () => { 
      filterModels(aiModel.value); 
    });
    aiModel.addEventListener("focus", () => {
      if (aiModel.value.trim()) {
        filterModels(aiModel.value);
      }
    });
    aiModel.addEventListener("blur", () => {
      // Hide dropdown after a delay to allow clicking on items
      setTimeout(() => {
        modelDropdown.style.display = 'none';
      }, 200);
    });
    aiModel.addEventListener("change", () => { markDirty(); updateGenerateButton(); saveAISettings(); });

    // Display settings event listeners
    themeSelect.addEventListener("change", () => { 
      applyTheme(themeSelect.value); 
      saveAISettings(); 
    });
    fontFamilySelect.addEventListener("change", () => { 
      applyFontFamily(fontFamilySelect.value); 
      saveAISettings(); 
    });
    fontSizeDesktop.addEventListener("input", () => { 
      updateFontSizeDisplay(fontSizeDesktop); 
      applyFontSize();
    });
    fontSizeDesktop.addEventListener("change", () => { 
      saveAISettings(); 
    });
    fontSizeMobile.addEventListener("input", () => { 
      updateFontSizeDisplay(fontSizeMobile); 
      applyFontSize();
    });
    fontSizeMobile.addEventListener("change", () => { 
      saveAISettings(); 
    });

    // Mobile UI settings event listeners
    if (hideMarkdownControls) {
      hideMarkdownControls.addEventListener("change", saveMobileSettings);
    }
    if (hideFooterConsole) {
      hideFooterConsole.addEventListener("change", saveMobileSettings);
    }
    
    // Window resize handler for mobile settings visibility
    window.addEventListener("resize", checkMobileSettings);
    
    // Pagination event listeners
    paginationEnabledCheckbox.addEventListener("change", () => {
      togglePagination(paginationEnabledCheckbox.checked);
      markDirty();
      saveAISettings();
    });
    
    pageSizeDesktop.addEventListener("input", () => {
      updatePageSizeDisplay(pageSizeDesktop);
      if (paginationEnabled) {
        isEditingPage = false; // Allow repagination when user changes page size
        initializePagination();
      }
    });
    
    pageSizeDesktop.addEventListener("change", () => {
      saveAISettings();
    });
    
    pageSizeMobile.addEventListener("input", () => {
      updatePageSizeDisplay(pageSizeMobile);
      if (paginationEnabled) {
        isEditingPage = false; // Allow repagination when user changes page size
        initializePagination();
      }
    });
    
    pageSizeMobile.addEventListener("change", () => {
      saveAISettings();
    });
    
    // Page navigation
    prevPageBtn.addEventListener("click", () => {
      if (currentPageIndex > 0) {
        switchToPage(currentPageIndex - 1);
      }
    });
    
    nextPageBtn.addEventListener("click", () => {
      if (currentPageIndex < pages.length - 1) {
        switchToPage(currentPageIndex + 1);
      }
    });
    
    // Page info click - jump to specific page
    pageInfo.addEventListener("click", () => {
      if (!paginationEnabled || pages.length <= 1) return;
      
      const targetPage = prompt(`Jump to page (1-${pages.length}):`);
      if (targetPage === null) return; // User cancelled
      
      const pageNum = parseInt(targetPage, 10);
      if (isNaN(pageNum) || pageNum < 1 || pageNum > pages.length) {
        alert(`Please enter a valid page number between 1 and ${pages.length}.`);
        return;
      }
      
      switchToPage(pageNum - 1); // Convert to 0-based index
    });



    // Drawer open/close
    const toggle = () => openMeta(metaPanel.getAttribute('data-open') !== '1');
    metaTab.addEventListener('click', () => { if (metaTab.getAttribute('aria-disabled') === 'true') return; toggle(); });
    metaScrim.addEventListener('click', () => openMeta(false));
    metaClose.addEventListener('click', () => openMeta(false));

    // Keyboard shortcuts
    window.addEventListener("keydown", (e) => {
      const isMac = navigator.platform.toLowerCase().includes("mac");
      const primary = isMac ? e.metaKey : e.ctrlKey;
      
      // Track CTRL state for Generate button
      const newCtrlState = isMac ? e.metaKey : e.ctrlKey;
      if (newCtrlState !== isCtrlHeld) {
        isCtrlHeld = newCtrlState;
        updateGenerateButtonForCtrl();
      }
      
      if (primary && e.key.toLowerCase() === "s") { e.preventDefault(); flushSave({ isUserAction: true }); return; }
      if (primary && e.key.toLowerCase() === "b") { e.preventDefault(); toggleBold(); return; }
      if (primary && e.key.toLowerCase() === "i") { e.preventDefault(); toggleItalic(); return; }
      if (primary && e.key.toLowerCase() === "u") { e.preventDefault(); toggleUnderline(); return; }
      if (primary && e.key.toLowerCase() === "h") { e.preventDefault(); toggleHidden(); return; }
      if (primary && e.shiftKey && e.key === "8") { e.preventDefault(); toggleBulleted(); return; }
      if (primary && /^[1-6]$/.test(e.key)) { e.preventDefault(); toggleHeading(parseInt(e.key,10)); headingSel.value = e.key; return; }
      // Alt+M toggles metadata drawer
      if ((e.altKey || e.metaKey && e.shiftKey) && e.key.toLowerCase() === 'm') { e.preventDefault(); const wantOpen = metaPanel.getAttribute('data-open') !== '1'; openMeta(wantOpen); return; }
      // Ctrl/Cmd+G generates AI content (if AI panel is open and configured)
      if (primary && e.key.toLowerCase() === 'g') { 
        if (metaPanel.getAttribute('data-open') === '1' && !fixedGenerateBtn.disabled) {
          e.preventDefault(); 
          generateAIContent(); 
        }
        return; 
      }

      if (e.key === 'Escape') { if (metaPanel.getAttribute('data-open') === '1') { e.preventDefault(); openMeta(false); } }
      if (e.key === "Tab") {
        const { start, end } = getSelection(editor);
        const lines = getSelectedLineRange(editor.value, start, end);
        if (lines.text.match(/^(\-\s|\s*)/m)) { e.preventDefault(); if (e.shiftKey) outdentSelection(); else indentSelection(); }
      }
    });
    
    // Track CTRL key release for Generate button
    window.addEventListener("keyup", (e) => {
      const isMac = navigator.platform.toLowerCase().includes("mac");
      const newCtrlState = isMac ? e.metaKey : e.ctrlKey;
      if (newCtrlState !== isCtrlHeld) {
        isCtrlHeld = newCtrlState;
        updateGenerateButtonForCtrl();
      }
    });

    // Formatting toolbar
    document.getElementById("bold-btn").addEventListener("click", () => { toggleBold(); updatePreview(); });
    document.getElementById("italic-btn").addEventListener("click", () => { toggleItalic(); updatePreview(); });
    document.getElementById("underline-btn").addEventListener("click", () => { toggleUnderline(); updatePreview(); });
    document.getElementById("hidden-btn").addEventListener("click", () => { toggleHidden(); updatePreview(); });
    document.getElementById("bullet-btn").addEventListener("click", () => { toggleBulleted(); updatePreview(); });
    document.getElementById("header-btn").addEventListener("click", () => { toggleHeading(1); headingSel.value = "1"; updatePreview(); });
    headingSel.addEventListener("change", () => { const lvl = parseInt(headingSel.value, 10); if (!isNaN(lvl)) { toggleHeading(lvl); updatePreview(); } });

    // Preview mode toggles - with retry to ensure DOM is ready
    function bindPreviewEvents() {
      const previewBtn = document.getElementById("toggle-preview");
      const splitBtn = document.getElementById("toggle-split");
      
      if (previewBtn && splitBtn) {
        previewBtn.addEventListener("click", () => { 
          const mode = document.body.getAttribute("data-mode"); 
          document.body.setAttribute("data-mode", mode === "preview" ? "edit" : "preview"); 
          updatePreview(); 
        });
        splitBtn.addEventListener("click", () => { 
          const mode = document.body.getAttribute("data-mode"); 
          document.body.setAttribute("data-mode", mode === "split" ? "edit" : "split"); 
          updatePreview(); 
        });
      } else {
        // Retry after a delay if buttons not found
        setTimeout(bindPreviewEvents, 100);
      }
    }
    bindPreviewEvents();

    // Save button in drawer
    metaSaveNow.addEventListener('click', () => flushSave({ isUserAction: true }));



    // Tab switching - with retry to ensure DOM is ready
    function bindTabEvents() {
      const tabBtns = document.querySelectorAll('.meta-tab-btn');
      if (tabBtns.length > 0) {
        tabBtns.forEach(btn => {
          btn.addEventListener('click', () => switchTab(btn.dataset.tab));
        });
      } else {
        // Retry after a short delay if buttons not found
        setTimeout(bindTabEvents, 100);
      }
    }
    bindTabEvents();

    // Fixed generate button
    fixedGenerateBtn.addEventListener('click', () => {
      if (isCtrlHeld) {
        openPreviewInput();
      } else {
        generateAIContent();
      }
    });
    cancelGenerateBtn.addEventListener('click', () => cancelGeneration());

    // Undo generate button
    undoGenerateBtn.addEventListener('click', () => undoGeneration());

    // Range input updates
    temperatureInput.addEventListener('input', () => {
      temperatureInput.nextElementSibling.textContent = temperatureInput.value;
      updateCostEstimate();
      markDirty();
      // Save AI settings after user stops typing
      clearTimeout(saveAISettingsTimer);
      saveAISettingsTimer = setTimeout(() => saveAISettings(), 2000);
    });
    topPInput.addEventListener('input', () => {
      topPInput.nextElementSibling.textContent = topPInput.value;
      updateCostEstimate();
      markDirty();
      // Save AI settings after user stops typing
      clearTimeout(saveAISettingsTimer);
      saveAISettingsTimer = setTimeout(() => saveAISettings(), 2000);
    });
    
    // Other AI settings changes
    maxOutputTokensInput.addEventListener('input', () => { 
      updateCostEstimate(); 
      markDirty(); 
      // Save AI settings after user stops typing
      clearTimeout(saveAISettingsTimer);
      saveAISettingsTimer = setTimeout(() => saveAISettings(), 2000);
    });
    maxInputCharactersInput.addEventListener('input', () => { 
      markDirty(); 
      // Save AI settings after user stops typing
      clearTimeout(saveAISettingsTimer);
      saveAISettingsTimer = setTimeout(() => saveAISettings(), 2000);
    });
    topKInput.addEventListener('input', () => { 
      updateCostEstimate(); 
      markDirty(); 
      // Save AI settings after user stops typing
      clearTimeout(saveAISettingsTimer);
      saveAISettingsTimer = setTimeout(() => saveAISettings(), 2000);
    });
    
    cleanAIOutput.addEventListener('change', () => { 
      markDirty(); 
      saveAISettings(); 
    });
    
    // Auto-refresh models when API key changes
    openrouterKey.addEventListener('input', () => { 
      markDirty(); 
      // Auto-fetch models if key looks valid (longer than 10 chars)
      if (openrouterKey.value.trim().length > 10) {
        refreshAvailableModelsWithRetry();
      }
    });

    window.addEventListener("visibilitychange", () => { if (document.visibilityState === "hidden") flushSave({ silent:true }); });
    window.addEventListener("beforeunload", () => { flushSave({ silent:true }); });
    
    // Story Dex event handlers
    storyDexBtn.addEventListener('click', openStoryDex);
    storyDexClose.addEventListener('click', closeStoryDex);
    storyDexModal.querySelector('.story-dex-overlay').addEventListener('click', closeStoryDex);
    addDexEntryBtn.addEventListener('click', addDexEntry);
    exportDexBtn.addEventListener('click', exportStoryDex);
    importDexBtn.addEventListener('click', () => importDexFile.click());
    importDexFile.addEventListener('change', importStoryDex);
    
    // Export Story event handlers
    exportStoryBtn.addEventListener('click', openExportStoryModal);
    exportStoryClose.addEventListener('click', closeExportStoryModal);
    exportStoryModal.querySelector('.story-dex-overlay').addEventListener('click', closeExportStoryModal);
    exportMarkdownBtn.addEventListener('click', exportAsMarkdown);
    exportRichTextBtn.addEventListener('click', exportAsRichText);
    
    // Preview Input event handlers
    previewInputBtn.addEventListener('click', openPreviewInput);
    previewInputClose.addEventListener('click', closePreviewInput);
    previewInputModal.querySelector('.preview-input-overlay').addEventListener('click', closePreviewInput);
    
    // Initialize display settings
    updateFontSizeRowVisibility();
    updateFontSizeDisplay(fontSizeDesktop);
    updateFontSizeDisplay(fontSizeMobile);
    
    // Initialize pagination settings
    updatePageSizeDisplay(pageSizeDesktop);
    updatePageSizeDisplay(pageSizeMobile);
    updatePageSizeRowVisibility();
    
    // Media query listener for responsive font size and pagination
    window.matchMedia('(max-width: 768px)').addEventListener('change', () => {
      updateFontSizeRowVisibility();
      updatePageSizeRowVisibility();
      applyFontSize();
      
      // Re-paginate if page size changed between desktop/mobile
      if (paginationEnabled) {
        isEditingPage = false;
        initializePagination();
      }
    });
    
    // Scroll and resize handlers removed - no longer needed for generate button positioning
  }

  // Drawer controller
  function openMeta(open) {
    metaPanel.setAttribute('data-open', open ? '1' : '0');
    metaScrim.setAttribute('data-open', open ? '1' : '0');
    metaTab.setAttribute('aria-expanded', String(open));
    if (open) {
      // Focus the first editable input for speedy tweaking
      setTimeout(() => { aiPreInput.focus(); aiPreInput.setSelectionRange(aiPreInput.value.length, aiPreInput.value.length); }, 80);
    } else {
      metaTab.focus();
    }
  }

  // Tab switching
  function switchTab(tabName) {
    // Hide all tab contents
    document.querySelectorAll('.tab-content').forEach(tab => tab.classList.remove('active'));
    document.querySelectorAll('.meta-tab-btn').forEach(btn => btn.classList.remove('active'));
    
    // Show selected tab
    document.getElementById(tabName + '-tab').classList.add('active');
    document.querySelector(`[data-tab="${tabName}"]`).classList.add('active');
    
    activeTab = tabName;
  }

  // =========================
  //  JSON header <-> UI
  // =========================
  function readMetaFromUI(){
    return {
      ai_pre_prompt: aiPreInput.value || "",
      next_instructions: nextInstInput.value || "",
      next_instructions_enabled: !!nextEnabled.checked,
      openrouter_key: rememberKey.checked ? (openrouterKey.value || "") : "",
      remember_key: !!rememberKey.checked,
      ai_model: aiModel.value || "",
      max_tokens: parseInt(maxOutputTokensInput.value) || 1000,
      max_input_characters: parseInt(maxInputCharactersInput.value) || 32000,
      temperature: parseFloat(temperatureInput.value) || 0.7,
      top_p: parseFloat(topPInput.value) || 1.0,
      top_k: parseInt(topKInput.value) || 0,
      story_dex: currentStoryDex
    };
  }
  
  function getDefaultAIPrePrompt() {
    return `You're a story writing AI:

- Write in third person, past tense.
- Continue from where you last left the story off without repeating what has already been written. Continue writing from midway through a sentence if necessary.`;
  }
  
  function writeMetaToUI(meta){
    aiPreInput.value = meta.ai_pre_prompt || "";
    nextInstInput.value = meta.next_instructions || "";
    nextEnabled.checked = !!meta.next_instructions_enabled;
    openrouterKey.value = meta.openrouter_key || "";
    rememberKey.checked = !!meta.remember_key;
    aiModel.value = meta.ai_model || "";
    maxOutputTokensInput.value = meta.max_tokens || 1000;
    maxInputCharactersInput.value = meta.max_input_characters || 32000;
    temperatureInput.value = meta.temperature || 0.7;
    topPInput.value = meta.top_p || 1.0;
    topKInput.value = meta.top_k || 0;
    
    // Update range displays
    temperatureInput.nextElementSibling.textContent = temperatureInput.value;
    topPInput.nextElementSibling.textContent = topPInput.value;
    
    // Load story dex data
    currentStoryDex = meta.story_dex || [];
    renderStoryDex();
    
    updateGenerateButton();
  }

  function buildFileText(meta, content){
    const json = JSON.stringify(meta, null, 2);
    return `${META_START}\n${json}\n${META_END}\n\n${content || ""}`;
  }
  function parseFileText(text){
    try {
      const s = text.indexOf(META_START);
      const e = text.indexOf(META_END);
      if (s !== -1 && e !== -1 && e > s){
        const jsonStr = text.slice(s + META_START.length, e).trim();
        const meta = JSON.parse(jsonStr);
        const after = text.slice(e + META_END.length).replace(/^\s*\n?/, "");
        return { meta: { ...DEFAULT_META, ...meta }, content: after };
      }
    } catch (err) { console.warn("Meta parse error; treating entire file as content.", err); }
    return { meta: { ...DEFAULT_META }, content: text };
  }

  // =========================
  //  Formatting helpers (Markdown-in-plaintext)
  // =========================
  function getSelection(el){ return { start: el.selectionStart, end: el.selectionEnd, value: el.value }; }
  function setSelection(el, start, end){ el.setSelectionRange(start, end); }
  function markDirty(){ dirty = true; lastInputTs = Date.now(); setSaveDot("saving"); scheduleAutosave(); }
  function applyChange(newValue, selStart, selEnd){ editor.value = newValue; setSelection(editor, selStart, selEnd); markDirty(); }

  function wrapOrUnwrapSelection(markerL, markerR, { altL = [], altR = [] } = {}){
    const { start, end, value } = getSelection(editor);
    const sel = value.slice(start, end); const before = value.slice(0, start); const after = value.slice(end);
    const allL = [markerL, ...altL]; const allR = [markerR, ...altR];
    const isWrapped = allL.some((L,i) => sel.startsWith(L) && sel.endsWith(allR[i] || markerR));
    if (isWrapped) {
      let unwrapped = sel;
      allL.forEach((L,i)=>{ const R = allR[i] || markerR; if (unwrapped.startsWith(L) && unwrapped.endsWith(R)) { unwrapped = unwrapped.slice(L.length, unwrapped.length - R.length); } });
      applyChange(before + unwrapped + after, start, start + unwrapped.length);
    } else {
      const insertL = markerL; const insertR = markerR;
      if (start === end) { const nv = before + insertL + insertR + after; const caret = (before + insertL).length; applyChange(nv, caret, caret); }
      else { const nv = before + insertL + sel + insertR + after; applyChange(nv, start + insertL.length, start + insertL.length + sel.length); }
    }
  }
  function toggleBold(){ wrapOrUnwrapSelection("**", "**", { altL:["__"], altR:["__"] }); }
  function toggleItalic(){ wrapOrUnwrapSelection("*", "*", { altL:["_"], altR:["_"] }); }
  function toggleUnderline(){ wrapOrUnwrapSelection("<u>", "</u>"); }
  function toggleHidden(){ wrapOrUnwrapSelection("[", "]"); }

  function getSelectedLineRange(text, start, end){ const lineStart = text.lastIndexOf("\n", start - 1) + 1; let lineEnd = text.indexOf("\n", end); if (lineEnd === -1) lineEnd = text.length; return { start: lineStart, end: lineEnd, text: text.slice(lineStart, lineEnd) }; }
  function toggleBulleted(){ const { start, end, value } = getSelection(editor); const range = getSelectedLineRange(value, start, end); const lines = value.slice(range.start, range.end).split("\n"); const allBulleted = lines.every(l => /^\s*-\s/.test(l) || l.trim() === ""); const changed = lines.map(l => { if (l.trim() === "") return l; if (allBulleted) return l.replace(/^\s*-\s?/, ""); return l.replace(/^\s*/, "$&- "); }).join("\n"); const nv = value.slice(0, range.start) + changed + value.slice(range.end); const delta = changed.length - (range.end - range.start); applyChange(nv, start + (start - range.start), end + delta - (range.end - end)); }
  function toggleHeading(level){ const { start, end, value } = getSelection(editor); const range = getSelectedLineRange(value, start, end); const lines = range.text.split("\n"); const prefix = "#".repeat(Math.min(Math.max(level,0),6)); const changed = lines.map(l => { if (l.trim() === "") return l; const cur = l.match(/^\s*(#{1,6})\s+/); if (level === 0) { return cur ? l.replace(/^\s*#{1,6}\s+/, "") : l; } if (cur && cur[1].length === level) { return l.replace(/^\s*#{1,6}\s+/, ""); } return l.replace(/^\s*(#{1,6}\s+)?/, prefix + " "); }).join("\n"); const nv = value.slice(0, range.start) + changed + value.slice(range.end); const delta = changed.length - (range.end - range.start); applyChange(nv, start, end + delta); }
  function indentSelection(){ const { start, end, value } = getSelection(editor); const range = getSelectedLineRange(value, start, end); const lines = range.text.split("\n"); const changed = lines.map(l => l.trim() === "" ? l : "  " + l).join("\n"); const nv = value.slice(0, range.start) + changed + value.slice(range.end); const delta = changed.length - (range.end - range.start); applyChange(nv, start + 2, end + delta + 2); }
  function outdentSelection(){ const { start, end, value } = getSelection(editor); const range = getSelectedLineRange(value, start, end); const lines = range.text.split("\n"); const changed = lines.map(l => l.replace(/^ {1,2}/, "")).join("\n"); const nv = value.slice(0, range.start) + changed + value.slice(range.end); const delta = changed.length - (range.end - range.start); applyChange(nv, Math.max(range.start, start - 2), Math.max(range.start, end + delta - 2)); }

  // =========================
  //  Markdown renderer (safe-ish)
  // =========================
  function escapeHtml(str){ return String(str).replaceAll('&','&amp;').replaceAll('<','&lt;').replaceAll('>','&gt;'); }
  function applyInline(md){ let s = escapeHtml(md); s = s.replace(/\[([^\]]*)\]/g, ''); s = s.replace(/\*\*([^\n*]+)\*\*/g, '<strong>$1</strong>'); s = s.replace(/(^|[^*])\*([^\n*]+)\*(?!\*)/g, '$1<em>$2</em>'); s = s.replace(/&lt;u&gt;([\s\S]*?)&lt;\/u&gt;/g, '<u>$1</u>'); return s; }
  function renderMarkdown(md){ 
    const lines = md.replace(/\r\n/g,'\n').split('\n'); 
    let html = ''; 
    let inList = false; 
    const flushList = () => { if (inList) { html += '</ul>'; inList = false; } }; 
    
    // Process lines and handle multiple empty lines
    for (let i = 0; i < lines.length; i++) { 
      const line = lines[i]; 
      
      // Check for headers
      const h = line.match(/^(#{1,6})\s+(.*)$/); 
      if (h){ 
        flushList(); 
        const lvl = h[1].length; 
        const text = h[2]; 
        html += `<h${lvl}>${applyInline(text)}</h${lvl}>`; 
        continue; 
      } 
      
      // Check for bulleted lists
      const b = line.match(/^\s*-\s+(.*)$/); 
      if (b){ 
        if (!inList){ html += '<ul>'; inList = true; } 
        html += `<li>${applyInline(b[1])}</li>`; 
        continue; 
      } 
      
      // Handle empty lines - look ahead for multiple consecutive empty lines
      if (/^\s*$/.test(line)) { 
        flushList(); 
        
        // Count consecutive empty lines
        let emptyCount = 1;
        let j = i + 1;
        while (j < lines.length && /^\s*$/.test(lines[j])) {
          emptyCount++;
          j++;
        }
        
        if (emptyCount >= 3) {
          // 3+ empty lines = 1.5x spacing
          html += '<div style="margin-bottom: 0.75em;"></div>'; 
        } else if (emptyCount === 2) {
          // 2 empty lines = 1.5x spacing
          html += '<div style="margin-bottom: 0.75em;"></div>'; 
        } else {
          // Single empty line = normal break
          html += '<br />'; 
        }
        
        // Skip the counted empty lines
        i = j - 1;
        continue; 
      } 
      
      // Regular paragraph
      flushList(); 
      html += `<p>${applyInline(line)}</p>`; 
    } 
    
    flushList(); 
    return sanitizeHTML(html); 
  }
  function sanitizeHTML(html){ const allowed = new Set(['H1','H2','H3','H4','H5','H6','P','STRONG','EM','U','UL','LI','BR']); const tmp = document.createElement('div'); tmp.innerHTML = html; (function walk(node){ const children = Array.from(node.childNodes); for (const child of children){ if (child.nodeType === 1){ if (!allowed.has(child.tagName)){ while (child.firstChild) node.insertBefore(child.firstChild, child); node.removeChild(child); continue; } const attrs = Array.from(child.attributes); for (const a of attrs) child.removeAttribute(a.name); walk(child); } } })(tmp); return tmp.innerHTML; }
  function updatePreview(){ previewEl.innerHTML = renderMarkdown(editor.value || ''); }

  // =========================
  //  AI Helper Functions
  // =========================
  function updateGenerateButton() {
    const hasKey = openrouterKey.value.trim().length > 0;
    const hasModel = aiModel.value.trim().length > 0;
    const canGenerate = hasKey && hasModel && !isGenerating;
    

    
    // Update fixed button
    fixedGenerateBtn.disabled = !canGenerate;
    fixedGenerateBtn.classList.toggle('visible', hasKey && hasModel);
    
    updateCostEstimate();
  }

  function updateCostEstimate() {
    if (!aiModel.value || !maxOutputTokensInput.value) {
      costEstimate.textContent = '~$0.00 per generation';
      return;
    }
    
    // Basic cost estimation (simplified)
    const tokens = parseInt(maxOutputTokensInput.value) || 1000;
    const modelCosts = {
      'anthropic/claude-3.5-sonnet': 0.000015,
      'anthropic/claude-3-haiku': 0.00000025,
      'openai/gpt-4o': 0.00001,
      'openai/gpt-4o-mini': 0.00000015,
      'meta-llama/llama-3.1-70b-instruct': 0.0000009,
      'meta-llama/llama-3.1-8b-instruct': 0.00000006
    };
    
    const costPerToken = modelCosts[aiModel.value] || 0.000001;
    const estimatedCost = tokens * costPerToken;
    
    costEstimate.textContent = `~$${estimatedCost.toFixed(4)} per generation`;
  }

  async function refreshAvailableModels() {
    if (!openrouterKey.value.trim()) {
      setStatus("Please enter OpenRouter API key first.");
      return;
    }
    
    try {
      setStatus("Fetching available models...");
      
      const response = await fetch("https://openrouter.ai/api/v1/models", {
        headers: {
          "Authorization": `Bearer ${openrouterKey.value.trim()}`,
        }
      });
      
      if (!response.ok) {
        throw new Error(`Failed to fetch models: ${response.status}`);
      }
      
      const data = await response.json();
      const models = data.data || [];
      
      // Store models for search functionality
      availableModels = models.map(model => {
        const pricing = model.pricing?.prompt || 0;
        const pricingNum = typeof pricing === 'number' ? pricing : parseFloat(pricing) || 0;
        return {
          id: model.id,
          name: model.id,
          pricing: pricingNum,
          displayText: `${model.id} - $${pricingNum.toFixed(6)}/1K tokens`
        };
      });
      
      setStatus("Models updated successfully.");
      // Reset retry counter on success
      modelLoadAttempts = 0;
      if (modelLoadRetryTimer) {
        clearTimeout(modelLoadRetryTimer);
        modelLoadRetryTimer = null;
      }
    } catch (error) {
      console.error("Failed to fetch models:", error);
      setStatus(`Failed to fetch models: ${error.message}`);
      throw error; // Re-throw the error so retry mechanism can catch it
    }
  }

  async function refreshAvailableModelsWithRetry() {
    // Clear any existing retry timer
    if (modelLoadRetryTimer) {
      clearTimeout(modelLoadRetryTimer);
      modelLoadRetryTimer = null;
    }

    if (!openrouterKey.value.trim()) {
      return; // No API key available, don't start retry loop
    }

    try {
      await refreshAvailableModels();
      // Success - reset attempts counter
      modelLoadAttempts = 0;
    } catch (error) {
      modelLoadAttempts++;
      
      if (modelLoadAttempts < maxModelLoadAttempts) {
        // Schedule retry with exponential backoff: 2^attempt seconds
        const retryDelay = Math.pow(2, modelLoadAttempts) * 1000;
        setStatus(`Model loading failed, retrying in ${retryDelay/1000}s... (${modelLoadAttempts}/${maxModelLoadAttempts})`);
        
        modelLoadRetryTimer = setTimeout(() => {
          refreshAvailableModelsWithRetry();
        }, retryDelay);
      } else {
        setStatus(`Failed to load models after ${maxModelLoadAttempts} attempts. Using default models.`);
        modelLoadAttempts = 0;
      }
    }
  }

  function filterModels(searchTerm) {
    const filtered = availableModels.filter(model => 
      model.id.toLowerCase().includes(searchTerm.toLowerCase())
    );
    
    modelDropdown.innerHTML = '';
    
    if (filtered.length > 0 && searchTerm.trim() !== '') {
      modelDropdown.style.display = 'block';
      filtered.slice(0, 10).forEach(model => { // Limit to 10 results
        const item = document.createElement('div');
        item.style.cssText = 'padding: 8px 12px; cursor: pointer; border-bottom: 1px solid #eee; font-size: 13px;';
        item.textContent = model.displayText;
        item.addEventListener('click', () => {
          aiModel.value = model.id;
          modelDropdown.style.display = 'none';
          updateGenerateButton();
          markDirty();
          saveAISettings();
        });
        item.addEventListener('mouseenter', () => {
          item.style.backgroundColor = '#f5f5f5';
        });
        item.addEventListener('mouseleave', () => {
          item.style.backgroundColor = 'white';
        });
        modelDropdown.appendChild(item);
      });
    } else {
      modelDropdown.style.display = 'none';
    }
  }

  function setGenerationState(generating) {
    isGenerating = generating;
    
    // Update UI elements
    fixedGenerateBtn.classList.toggle('generating', generating);
    updateGenerateButtonForCtrl(); // Use our function that considers CTRL state
    fixedGenerateBtn.disabled = generating;
    
    cancelGenerateBtn.classList.toggle('visible', generating);
    
    // Disable/enable editor during generation
    editor.disabled = generating;
    if (generating) {
      editor.style.opacity = '0.7';
      editor.style.pointerEvents = 'none';
    } else {
      editor.style.opacity = '1';
      editor.style.pointerEvents = 'auto';
    }
    
    updateGenerateButton();
  }

  function cancelGeneration() {
    if (generationController) {
      generationController.abort();
      generationController = null;
    }
    setGenerationState(false);
    setStatus("Generation cancelled.");
  }

  function undoGeneration() {
    if (!hasUndoableGeneration || !lastContentBeforeGeneration) {
      setStatus("No AI generation to undo.");
      return;
    }

    // Check if user has made changes since last generation
    if (contentChangedSinceGeneration) {
      const shouldUndo = confirm(
        "You have made changes since the last AI generation. " +
        "Undoing will lose these changes. Continue?"
      );
      if (!shouldUndo) {
        setStatus("Undo cancelled.");
        return;
      }
    }

    // Restore the content from before generation
    const currentSelection = getSelection(editor);
    editor.value = lastContentBeforeGeneration;
    
    // Try to restore cursor position, or place at end if position is invalid
    try {
      setSelection(editor, currentSelection.start, currentSelection.end);
    } catch (e) {
      // If selection position is invalid, place cursor at end
      const endPos = editor.value.length;
      setSelection(editor, endPos, endPos);
    }

    // Update state
    hasUndoableGeneration = false;
    contentChangedSinceGeneration = false;
    lastContentBeforeGeneration = null;

    // Update UI
    undoGenerateBtn.classList.remove('visible');
    updatePreview();
    markDirty();

    // Handle pagination if active
    if (paginationEnabled) {
      isEditingPage = false;
      if (pages[currentPageIndex]) {
        pages[currentPageIndex].content = editor.value;
      }
      fullContent = rebuildFullContent();
      initializePagination();
    }

    setStatus("AI generation undone.");
  }

  function findMatchingStoryDexEntries(text) {
    if (!text || !currentStoryDex || currentStoryDex.length === 0) {
      return [];
    }

    const matchedEntries = [];
    const seenEntryIds = new Set();

    // For each Story Dex entry
    for (const entry of currentStoryDex) {
      if (!entry.keywords || !entry.keywords.trim()) {
        continue;
      }

      // Split keywords by comma and check each one
      const keywords = entry.keywords.split(',').map(k => k.trim()).filter(k => k);
      
      for (const keyword of keywords) {
        if (!keyword) continue;

        // Create regex for whole word matching with optional plural 's'
        // \b ensures word boundaries, and s? makes the 's' optional for plurals
        const regex = new RegExp(`\\b${keyword.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}s?\\b`, 'gi');
        
        if (regex.test(text)) {
          // Found a match, add entry if not already added
          if (!seenEntryIds.has(entry.id)) {
            matchedEntries.push(entry);
            seenEntryIds.add(entry.id);
          }
          break; // No need to check other keywords for this entry
        }
      }
    }

    return matchedEntries;
  }

  function buildAIPrompt() {
    // Get the full content
      const currentContent = getFullContent() || "";
      
      // Apply max input length limit - keep only recent paragraphs if content is too long
      let limitedContent = currentContent;
      const maxInputLength = parseInt(maxInputCharactersInput.value) || 32000; // Use user-configured limit
      
      if (currentContent.length > maxInputLength) {
        const paragraphs = currentContent.split(/\n\s*\n/).filter(p => p.trim());
        let totalLength = 0;
        const recentParagraphs = [];
        
        // Work backwards from the end to include the most recent paragraphs
        for (let i = paragraphs.length - 1; i >= 0; i--) {
          const paragraph = paragraphs[i];
          if (totalLength + paragraph.length > maxInputLength && recentParagraphs.length > 0) {
            break;
          }
          recentParagraphs.unshift(paragraph);
          totalLength += paragraph.length + 2; // +2 for paragraph separator
        }
        
        limitedContent = recentParagraphs.join('\n\n');
        if (recentParagraphs.length < paragraphs.length) {
          setStatus(`Content truncated to recent ${recentParagraphs.length} paragraphs due to length limit.`);
        }
      }
      
      // Build the prompt
      let prompt = "";
      if (aiPreInput.value.trim()) {
        prompt += `[${aiPreInput.value.trim()}]\n\n`;
      }
      prompt += limitedContent;
      
      // Add next instructions if enabled - append to most recent complete paragraph
      if (nextEnabled.checked && nextInstInput.value.trim()) {
        // Find paragraphs (separated by double newlines or end of text)
        const paragraphs = limitedContent.split(/\n\s*\n/).filter(p => p.trim());
        if (paragraphs.length > 0) {
          // Check if the last paragraph looks complete (ends with punctuation)
          const lastParagraph = paragraphs[paragraphs.length - 1].trim();
          if (lastParagraph && /[.!?]$/.test(lastParagraph)) {
            prompt += `\n\n[${nextInstInput.value.trim()}]`;
          } else {
            // If no complete paragraph, just add instructions at the end
            prompt += `\n\n[${nextInstInput.value.trim()}]`;
          }
        } else {
          // No paragraphs yet, add instructions
          prompt += `\n\n[${nextInstInput.value.trim()}]`;
        }
      }

      // Find and add Story Dex entries based on keyword matches
      let textToScan = limitedContent;
      if (nextEnabled.checked && nextInstInput.value.trim()) {
        textToScan += '\n\n' + nextInstInput.value.trim();
      }
      
      const matchedDexEntries = findMatchingStoryDexEntries(textToScan);
      if (matchedDexEntries.length > 0) {
        const dexEntriesText = matchedDexEntries
          .map(entry => `[${entry.name}: ${entry.description}]`)
          .join('\n');
        
        // Insert Story Dex entries after preprompt but before main content
        if (aiPreInput.value.trim()) {
          // If there's a preprompt, add Story Dex entries after it
          prompt = `[${aiPreInput.value.trim()}]\n\n${dexEntriesText}\n\n${limitedContent}`;
        } else {
          // If no preprompt, add Story Dex entries at the beginning
          prompt = `${dexEntriesText}\n\n${limitedContent}`;
        }
        
        // Re-add next instructions if they were in the original prompt
        if (nextEnabled.checked && nextInstInput.value.trim()) {
          const paragraphs = limitedContent.split(/\n\s*\n/).filter(p => p.trim());
          if (paragraphs.length > 0) {
            const lastParagraph = paragraphs[paragraphs.length - 1].trim();
            if (lastParagraph && /[.!?]$/.test(lastParagraph)) {
              prompt += `\n\n[${nextInstInput.value.trim()}]`;
            } else {
              prompt += `\n\n[${nextInstInput.value.trim()}]`;
            }
          } else {
            prompt += `\n\n[${nextInstInput.value.trim()}]`;
          }
        }
        
        // Check if the new prompt exceeds max input length and truncate if needed
        const maxInputLength = parseInt(maxInputCharactersInput.value) || 32000;
        if (prompt.length > maxInputLength) {
          // We need to truncate content while preserving preprompt, Story Dex entries, and next instructions
          let preservedStart = '';
          let preservedEnd = '';
          
          if (aiPreInput.value.trim()) {
            preservedStart += `[${aiPreInput.value.trim()}]\n\n`;
          }
          preservedStart += dexEntriesText + '\n\n';
          
          if (nextEnabled.checked && nextInstInput.value.trim()) {
            preservedEnd = `\n\n[${nextInstInput.value.trim()}]`;
          }
          
          const availableLength = maxInputLength - preservedStart.length - preservedEnd.length;
          
          if (availableLength > 100) { // Ensure we have some reasonable space for content
            const paragraphs = limitedContent.split(/\n\s*\n/).filter(p => p.trim());
            let truncatedContent = '';
            let totalLength = 0;
            
            // Work backwards from the end to include the most recent paragraphs
            for (let i = paragraphs.length - 1; i >= 0; i--) {
              const paragraph = paragraphs[i];
              if (totalLength + paragraph.length + 2 > availableLength && truncatedContent) {
                break;
              }
              truncatedContent = paragraph + (truncatedContent ? '\n\n' + truncatedContent : '');
              totalLength += paragraph.length + 2;
            }
            
            prompt = preservedStart + truncatedContent + preservedEnd;
            
            if (truncatedContent.length < limitedContent.length) {
              const truncatedParagraphs = truncatedContent.split(/\n\s*\n/).filter(p => p.trim()).length;
              setStatus(`Content truncated to recent ${truncatedParagraphs} paragraphs due to length limit (including ${matchedDexEntries.length} Story Dex entries).`);
            }
          }
        }
      }

      return prompt;
  }

  async function generateAIContent() {
    if (!openrouterKey.value.trim() || !aiModel.value.trim()) {
      setStatus("Please enter OpenRouter API key and select a model.");
      return;
    }

    if (isGenerating) {
      setStatus("Generation already in progress.");
      return;
    }

    try {
      // Save content before generation for undo functionality
      lastContentBeforeGeneration = editor.value;
      hasUndoableGeneration = false; // Will be set to true on successful generation
      contentChangedSinceGeneration = false;
      
      generationController = new AbortController();
      setGenerationState(true);
      setStatus("Generating AI content...");

      // Jump to last page when starting generation (after validation)
      jumpToLastPageAndScrollToBottom();

      // Build the prompt using the extracted function
      const prompt = buildAIPrompt();

      // Build request body with enhanced settings
      const requestBody = {
        model: aiModel.value,
        messages: [
          {
            role: "user",
            content: prompt
          }
        ],
        max_tokens: parseInt(maxOutputTokensInput.value) || 1000,
        temperature: parseFloat(temperatureInput.value) || 0.7,
        top_p: parseFloat(topPInput.value) || 1.0
      };

      // Add top_k if specified
      if (topKInput.value && parseInt(topKInput.value) > 0) {
        requestBody.top_k = parseInt(topKInput.value);
      }

      // Call OpenRouter API
      const response = await fetch("https://openrouter.ai/api/v1/chat/completions", {
        method: "POST",
        headers: {
          "Authorization": `Bearer ${openrouterKey.value.trim()}`,
          "Content-Type": "application/json",
          "HTTP-Referer": window.location.origin,
          "X-Title": "Ghostwriter"
        },
        body: JSON.stringify(requestBody),
        signal: generationController.signal
      });

      if (!response.ok) {
        let errorMessage = `OpenRouter API error: ${response.status} ${response.statusText}`;
        const errorText = await response.text();
        
        // Provide helpful error messages for common issues
        if (response.status === 401) {
          errorMessage = "Invalid API key. Please check your OpenRouter API key.";
        } else if (response.status === 429) {
          errorMessage = "Rate limit exceeded. Please wait a moment and try again.";
        } else if (response.status === 402) {
          errorMessage = "Insufficient credits. Please check your OpenRouter account balance.";
        } else if (errorText) {
          try {
            const errorData = JSON.parse(errorText);
            if (errorData.error?.message) {
              errorMessage += `: ${errorData.error.message}`;
            }
          } catch {
            errorMessage += `: ${errorText}`;
          }
        }
        
        throw new Error(errorMessage);
      }

      const data = await response.json();
      let generatedText = data.choices?.[0]?.message?.content?.trim();

      if (!generatedText) {
        throw new Error("No content generated from AI model.");
      }

      // Clean the AI output if the toggle is enabled
      generatedText = cleanGeneratedText(generatedText);

      // Insert the generated content at the cursor position or end of editor
      const { start, end } = getSelection(editor);
      const before = editor.value.slice(0, start);
      const after = editor.value.slice(end);
      
      // Add appropriate spacing
      let insertText = generatedText;
      if (before && !before.endsWith('\n\n')) {
        insertText = '\n\n' + insertText;
      }
      
      const newValue = before + insertText + after;
      const newCursorPos = start + insertText.length;
      
      applyChange(newValue, newCursorPos, newCursorPos);
      updatePreview();
      
      // Reset editing flag and trigger repagination after AI content generation
      if (paginationEnabled) {
        isEditingPage = false;
        // Update current page with the new content (including AI generation)
        if (pages[currentPageIndex]) {
          pages[currentPageIndex].content = editor.value;
        }
        // Rebuild full content from all pages to preserve other pages
        fullContent = rebuildFullContent();
        initializePagination();
      }
      
      // Jump to last page and scroll to bottom after successful generation
      jumpToLastPageAndScrollToBottom();
      
      // Enable undo functionality after successful generation
      hasUndoableGeneration = true;
      contentChangedSinceGeneration = false;
      undoGenerateBtn.classList.add('visible');
      
      setStatus("AI content generated successfully.");
    } catch (error) {
      // Reset undo state if generation fails
      lastContentBeforeGeneration = null;
      hasUndoableGeneration = false;
      contentChangedSinceGeneration = false;
      
      if (error.name === 'AbortError') {
        setStatus("Generation cancelled.");
      } else {
        console.error("AI generation error:", error);
        setStatus(`AI generation failed: ${error.message}`);
      }
    } finally {
      setGenerationState(false);
      generationController = null;
    }
  }

  // =========================
  //  Preview Input Functions
  // =========================
  function openPreviewInput() {
    try {
      const prompt = buildAIPrompt();
      previewInputText.textContent = prompt;
      previewInputModal.setAttribute('data-open', '1');
    } catch (error) {
      console.error("Error building preview:", error);
      previewInputText.textContent = "Error building prompt: " + error.message;
      previewInputModal.setAttribute('data-open', '1');
    }
  }
  
  function closePreviewInput() {
    previewInputModal.setAttribute('data-open', '0');
  }
  
  function updateGenerateButtonForCtrl() {
    if (isCtrlHeld && !isGenerating) {
      fixedGenerateBtn.textContent = 'Preview Input';
      fixedGenerateBtn.title = 'Preview AI input (Ctrl/⌘+G)';
    } else {
      fixedGenerateBtn.textContent = isGenerating ? 'Generating...' : 'Generate with AI';
      fixedGenerateBtn.title = 'Generate AI content (Ctrl/⌘+G)';
    }
  }



  // =========================
  //  AI Output Cleaning Functions
  // =========================
  function cleanGeneratedText(text) {
    if (!cleanAIOutput.checked || !text) {
      return text;
    }

    let cleaned = text;

    // 1. Trim unfinished sentences from output
    // Find the last complete sentence (ending with . ! or ?)
    const sentences = cleaned.split(/([.!?]+)/);
    if (sentences.length > 1) {
      // Check if the last part (after the last punctuation) looks incomplete
      const lastPart = sentences[sentences.length - 1].trim();
      // If there's substantial text after the last punctuation, it might be incomplete
      if (lastPart.length > 0 && lastPart.length < 200 && !lastPart.match(/^[.!?\s]*$/)) {
        // Remove the incomplete sentence
        sentences.pop();
        cleaned = sentences.join('');
      }
    }

    // 2. Replace curly quotes with regular quotes
    cleaned = cleaned.replace(/[""]/g, '"').replace(/['']/g, "'");

    // 3. Delete square brackets and anything contained within them
    cleaned = cleaned.replace(/\[.*?\]/g, '');

    return cleaned.trim();
  }

  // =========================
  //  Story Dex Functions
  // =========================
  function openStoryDex() {
    storyDexModal.setAttribute('data-open', '1');
    renderStoryDex();
  }
  
  function closeStoryDex() {
    // Sort entries alphabetically by name before closing
    currentStoryDex.sort((a, b) => {
      const nameA = (a.name || '').toLowerCase();
      const nameB = (b.name || '').toLowerCase();
      return nameA.localeCompare(nameB);
    });
    storyDexModal.setAttribute('data-open', '0');
    // Re-render to show the sorted order
    renderStoryDex();
    markDirty();
  }
  
  function addDexEntry() {
    const newEntry = {
      id: Date.now(), // Simple ID based on timestamp
      name: '',
      description: '',
      keywords: ''
    };
    currentStoryDex.unshift(newEntry); // Add to the beginning instead of end
    renderStoryDex();
    markDirty();
  }
  
  function removeDexEntry(id) {
    currentStoryDex = currentStoryDex.filter(entry => entry.id !== id);
    renderStoryDex();
    markDirty();
  }
  
  function updateDexEntry(id, field, value) {
    const entry = currentStoryDex.find(entry => entry.id === id);
    if (entry) {
      entry[field] = value;
      markDirty();
    }
  }
  
  function renderStoryDex() {
    if (!storyDexEntries) return;
    
    if (currentStoryDex.length === 0) {
      storyDexEntries.innerHTML = '<p style="color: #666; text-align: center; padding: 20px;">No entries yet. Add your first character, location, or concept!</p>';
      return;
    }
    
    storyDexEntries.innerHTML = currentStoryDex.map(entry => `
      <div class="dex-entry" data-id="${entry.id}">
        <div class="dex-entry-header">
          <input 
            type="text" 
            class="dex-entry-name" 
            placeholder="Name (e.g., Character, Location, Item)"
            value="${escapeHtml(entry.name || '')}"
            data-field="name"
            data-id="${entry.id}"
            style="
              font-weight: 600;
              font-size: 16px;
              border: none;
              background: transparent;
              width: 100%;
              padding: 4px 0;
              margin-bottom: 8px;
            "
          />
          <button 
            class="remove-dex-entry" 
            data-id="${entry.id}"
            style="
              background: #dc3545;
              color: white;
              border: none;
              padding: 4px 8px;
              border-radius: 4px;
              cursor: pointer;
              font-size: 12px;
            "
          >Remove</button>
        </div>
        <textarea 
          class="dex-entry-description" 
          placeholder="Description..."
          data-field="description"
          data-id="${entry.id}"
          style="
            width: 100%;
            min-height: 100px;
            border: 1px solid var(--line);
            border-radius: 4px;
            padding: 8px;
            margin-bottom: 8px;
            resize: vertical;
          "
        >${escapeHtml(entry.description || '')}</textarea>
        <input 
          type="text" 
          class="dex-entry-keywords" 
          placeholder="Keywords (comma-separated)"
          value="${escapeHtml(entry.keywords || '')}"
          data-field="keywords"
          data-id="${entry.id}"
          style="
            width: 100%;
            border: 1px solid var(--line);
            border-radius: 4px;
            padding: 8px;
            font-size: 14px;
          "
        />
      </div>
    `).join('');
    
    // Add event listeners for the dynamically created elements
    storyDexEntries.querySelectorAll('.dex-entry-name, .dex-entry-description, .dex-entry-keywords').forEach(input => {
      input.addEventListener('input', (e) => {
        const id = parseInt(e.target.dataset.id);
        const field = e.target.dataset.field;
        updateDexEntry(id, field, e.target.value);
      });
    });
    
    storyDexEntries.querySelectorAll('.remove-dex-entry').forEach(btn => {
      btn.addEventListener('click', (e) => {
        const id = parseInt(e.target.dataset.id);
        removeDexEntry(id);
      });
    });
  }

  function exportStoryDex() {
    if (currentStoryDex.length === 0) {
      setStatus("No Story Dex entries to export.");
      return;
    }
    
    const dataStr = JSON.stringify(currentStoryDex, null, 2);
    const dataBlob = new Blob([dataStr], { type: 'application/json' });
    const url = URL.createObjectURL(dataBlob);
    
    const a = document.createElement('a');
    a.href = url;
    a.download = `story-dex-${new Date().toISOString().slice(0, 10)}.json`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
    
    setStatus(`Exported ${currentStoryDex.length} Story Dex entries.`);
  }

  async function importStoryDex(event) {
    const file = event.target.files[0];
    if (!file) return;

    try {
      const text = await file.text();
      const importedEntries = JSON.parse(text);
      
      if (!Array.isArray(importedEntries)) {
        setStatus("Invalid file format. Expected JSON array.");
        return;
      }

      // Validate entries have required fields
      const validEntries = importedEntries.filter(entry => 
        entry && typeof entry === 'object' && 
        typeof entry.name === 'string'
      );

      if (validEntries.length === 0) {
        setStatus("No valid entries found in import file.");
        return;
      }

      // Find potential overwrites (case insensitive name matching)
      const existingNames = currentStoryDex.map(entry => (entry.name || '').toLowerCase());
      const overwrites = validEntries.filter(entry => 
        existingNames.includes((entry.name || '').toLowerCase())
      );

      // Show confirmation if there are overwrites
      if (overwrites.length > 0) {
        const confirmed = confirm(
          `This import will overwrite ${overwrites.length} existing entries with the same names. Continue?`
        );
        if (!confirmed) {
          event.target.value = ''; // Reset file input
          return;
        }
      }

      // Perform the merge
      const mergedEntries = [...currentStoryDex];
      
      validEntries.forEach(importedEntry => {
        // Ensure the entry has all required fields
        const entry = {
          id: importedEntry.id || Date.now() + Math.random(), // Generate new ID if missing
          name: importedEntry.name || '',
          description: importedEntry.description || '',
          keywords: importedEntry.keywords || ''
        };

        // Find if entry with same name already exists (case insensitive)
        const existingIndex = mergedEntries.findIndex(existing => 
          (existing.name || '').toLowerCase() === (entry.name || '').toLowerCase()
        );

        if (existingIndex !== -1) {
          // Replace existing entry
          mergedEntries[existingIndex] = entry;
        } else {
          // Add new entry
          mergedEntries.push(entry);
        }
      });

      currentStoryDex = mergedEntries;
      renderStoryDex();
      markDirty();
      
      setStatus(`Imported ${validEntries.length} entries. ${overwrites.length} entries were overwritten.`);
      
    } catch (error) {
      console.error('Import error:', error);
      setStatus("Failed to import Story Dex. Invalid JSON format.");
    }

    // Reset file input for next import
    event.target.value = '';
  }

  // =========================
  //  Export Story Functions
  // =========================
  function openExportStoryModal() {
    if (!editor.value.trim()) {
      setStatus("No story content to export.");
      return;
    }
    exportStoryModal.setAttribute('data-open', '1');
  }
  
  function closeExportStoryModal() {
    exportStoryModal.setAttribute('data-open', '0');
  }
  
  function exportAsMarkdown() {
    const content = editor.value;
    if (!content.trim()) {
      setStatus("No story content to export.");
      return;
    }
    
    const filename = `story-markdown-${new Date().toISOString().slice(0, 10)}.txt`;
    downloadStoryFile(content, filename);
    setStatus("Story exported as Markdown.");
    closeExportStoryModal();
  }
  
  function exportAsRichText() {
    const content = editor.value;
    if (!content.trim()) {
      setStatus("No story content to export.");
      return;
    }
    
    // Remove content in square brackets (hidden text)
    const cleanedContent = content.replace(/\[.*?\]/g, '');
    
    const filename = `story-richtext-${new Date().toISOString().slice(0, 10)}.txt`;
    downloadStoryFile(cleanedContent, filename);
    setStatus("Story exported as Rich Text (hidden content removed).");
    closeExportStoryModal();
  }
  
  function downloadStoryFile(content, filename) {
    const dataBlob = new Blob([content], { type: 'text/plain' });
    const url = URL.createObjectURL(dataBlob);
    
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  }

  // =========================
  //  AI Settings Persistence (Google Drive AppData)
  // =========================
  async function findAISettingsFile(isUserAction = false) {
    try {
      const url = new URL(DRIVE_FILES_URL);
      url.searchParams.set("q", `name='${AI_SETTINGS_FILENAME}' and parents in 'appdata'`);
      url.searchParams.set("spaces", "appdata");
      url.searchParams.set("fields", "files(id,name)");
      
      const res = await fetch(url.toString(), { headers: authHeader() });
      if (res.status === 401) { await handleUnauthorized(isUserAction); return findAISettingsFile(isUserAction); }
      if (!res.ok) throw new Error(`Find AI settings failed: ${res.status}`);
      
      const { files } = await res.json();
      return files && files.length > 0 ? files[0].id : null;
    } catch (e) {
      console.warn("Failed to find AI settings file:", e);
      return null;
    }
  }

  async function loadAISettings(isUserAction = false) {
    if (!accessToken || aiSettingsLoaded) return;
    
    try {
      aiSettingsFileId = await findAISettingsFile(isUserAction);
      if (!aiSettingsFileId) {
        aiSettingsLoaded = true;
        return; // No settings file exists yet
      }

      const res = await fetch(`${DRIVE_FILES_URL}/${aiSettingsFileId}?alt=media`, { headers: authHeader() });
      if (res.status === 401) { await handleUnauthorized(isUserAction); return loadAISettings(isUserAction); }
      if (!res.ok) throw new Error(`Load AI settings failed: ${res.status}`);
      
      const settingsText = await res.text();
      const settings = JSON.parse(settingsText);
      
      // Apply settings to UI (but only if remember_key is true for API key)
      if (settings.ai_model) {
        aiModel.value = settings.ai_model;
      }
      if (settings.remember_key && settings.openrouter_key) {
        openrouterKey.value = settings.openrouter_key;
        rememberKey.checked = true;
        // Auto-refresh models when API key is loaded from saved settings
        // Use setTimeout to ensure DOM is updated before fetching models
        setTimeout(() => {
          refreshAvailableModelsWithRetry();
        }, 100);
      } else {
        rememberKey.checked = false;
      }
      
      // Apply AI parameters
      if (settings.max_tokens !== undefined) {
        maxOutputTokensInput.value = settings.max_tokens;
      }
      if (settings.max_input_characters !== undefined) {
        maxInputCharactersInput.value = settings.max_input_characters;
      }
      if (settings.temperature !== undefined) {
        temperatureInput.value = settings.temperature;
        temperatureInput.nextElementSibling.textContent = settings.temperature;
      }
      if (settings.top_p !== undefined) {
        topPInput.value = settings.top_p;
        topPInput.nextElementSibling.textContent = settings.top_p;
      }
      if (settings.top_k !== undefined) {
        topKInput.value = settings.top_k;
      }
      if (settings.clean_ai_output !== undefined) {
        cleanAIOutput.checked = settings.clean_ai_output;
      }
      
      // Apply display preferences
      if (settings.theme) {
        themeSelect.value = settings.theme;
        applyTheme(settings.theme);
      }
      if (settings.font_family) {
        fontFamilySelect.value = settings.font_family;
        applyFontFamily(settings.font_family);
      }
      if (settings.font_size_desktop) {
        fontSizeDesktop.value = settings.font_size_desktop;
        updateFontSizeDisplay(fontSizeDesktop);
      }
      if (settings.font_size_mobile) {
        fontSizeMobile.value = settings.font_size_mobile;
        updateFontSizeDisplay(fontSizeMobile);
      }
      
      // Load pagination settings
      if (settings.pagination_enabled !== undefined) {
        paginationEnabledCheckbox.checked = settings.pagination_enabled;
        togglePagination(settings.pagination_enabled);
      }
      if (settings.page_size_desktop) {
        pageSizeDesktop.value = settings.page_size_desktop;
        updatePageSizeDisplay(pageSizeDesktop);
      }
      if (settings.page_size_mobile) {
        pageSizeMobile.value = settings.page_size_mobile;
        updatePageSizeDisplay(pageSizeMobile);
      }
      
      // Update page size row visibility after loading pagination settings
      updatePageSizeRowVisibility();
      
      // Apply current font size based on screen size
      applyFontSize();
      
      updateGenerateButton();
      aiSettingsLoaded = true;
      console.log("AI settings loaded from Drive");
    } catch (e) {
      console.warn("Failed to load AI settings:", e);
      aiSettingsLoaded = true;
    }
  }

  // =========================
  //  Display Settings Helpers
  // =========================
  function applyTheme(theme) {
    document.body.setAttribute('data-theme', theme);
  }

  function applyFontFamily(family) {
    document.body.setAttribute('data-font-family', family);
  }

  function applyFontSize() {
    const isMobile = window.matchMedia('(max-width: 768px)').matches;
    const fontSize = isMobile ? fontSizeMobile.value : fontSizeDesktop.value;
    document.documentElement.style.setProperty('--editor-font-size', fontSize + 'px');
  }

  function updateFontSizeDisplay(slider) {
    const rangeValue = slider.parentNode.querySelector('.range-value');
    if (rangeValue) {
      rangeValue.textContent = slider.value + 'px';
    }
  }

  function updateFontSizeRowVisibility() {
    const isMobile = window.matchMedia('(max-width: 768px)').matches;
    if (isMobile) {
      desktopFontRow.style.display = 'none';
      mobileFontRow.style.display = 'grid';
    } else {
      desktopFontRow.style.display = 'grid';
      mobileFontRow.style.display = 'none';
    }
  }

  // =========================
  //  Pagination Helpers
  // =========================

  function getCurrentPageSize() {
    const isMobile = window.matchMedia('(max-width: 768px)').matches;
    return parseInt(isMobile ? pageSizeMobile.value : pageSizeDesktop.value) || (isMobile ? 10000 : 20000);
  }
  
  function splitContentIntoPages(content) {
    if (!paginationEnabled || !content) {
      return [{ content: content || '', startIndex: 0 }];
    }
    
    const pageSize = getCurrentPageSize();
    const pages = [];
    
    // Split by paragraphs first
    const paragraphs = content.split(/\n\s*\n/);
    let currentPage = '';
    let currentPageStartIndex = 0;
    
    for (let i = 0; i < paragraphs.length; i++) {
      const paragraph = paragraphs[i];
      const potentialPage = currentPage + (currentPage ? '\n\n' : '') + paragraph;
      
      // If adding this paragraph would exceed page size and we have content
      if (potentialPage.length > pageSize && currentPage) {
        // Save current page
        pages.push({
          content: currentPage,
          startIndex: currentPageStartIndex
        });
        
        // Start new page
        currentPage = paragraph;
        currentPageStartIndex = content.indexOf(paragraph, currentPageStartIndex + currentPage.length);
      } else {
        currentPage = potentialPage;
      }
    }
    
    // Add the last page if there's content
    if (currentPage) {
      pages.push({
        content: currentPage,
        startIndex: currentPageStartIndex
      });
    }
    
    return pages.length > 0 ? pages : [{ content: '', startIndex: 0 }];
  }
  
  function rebuildFullContent() {
    return pages.map(page => page.content).join('\n\n');
  }
  
  function updatePaginationState() {
    if (!paginationEnabled) {
      paginationControls.style.display = 'none';
      document.body.removeAttribute('data-pagination-active');
      return;
    }
    
    paginationControls.style.display = 'block';
    document.body.setAttribute('data-pagination-active', 'true');
    
    // Update navigation buttons
    prevPageBtn.disabled = currentPageIndex === 0;
    nextPageBtn.disabled = currentPageIndex >= pages.length - 1;
    
    // Update page info
    pageInfo.textContent = `Page ${currentPageIndex + 1} of ${pages.length}`;
    
    // Update progress bar
    const progress = pages.length > 1 ? (currentPageIndex / (pages.length - 1)) * 100 : 100;
    pageProgressFill.style.width = `${progress}%`;
    
    // Update page details
    const currentPage = pages[currentPageIndex];
    const charCount = currentPage ? currentPage.content.length : 0;
    pageDetails.textContent = `${charCount.toLocaleString()} characters`;
  }
  
  function switchToPage(pageIndex) {
    if (pageIndex < 0 || pageIndex >= pages.length) return;
    
    // Save current page content before switching
    if (pages[currentPageIndex]) {
      pages[currentPageIndex].content = editor.value;
    }
    
    currentPageIndex = pageIndex;
    
    // Load new page content
    const currentPage = pages[currentPageIndex];
    if (currentPage) {
      editor.value = currentPage.content;
    }
    
    updatePaginationState();
    updatePreview();
  }
  
  function initializePagination() {
    if (!paginationEnabled) {
      pages = [{ content: fullContent, startIndex: 0 }];
      currentPageIndex = 0;
      editor.value = fullContent;
      updatePaginationState();
      return;
    }
    
    pages = splitContentIntoPages(fullContent);
    currentPageIndex = Math.min(currentPageIndex, pages.length - 1);
    
    const currentPage = pages[currentPageIndex];
    editor.value = currentPage ? currentPage.content : '';
    
    updatePaginationState();
    updatePreview();
  }
  
  function togglePagination(enabled) {
    if (enabled === paginationEnabled) return;
    
    paginationEnabled = enabled;
    
    if (enabled) {
      // Save current editor content as full content
      fullContent = editor.value;
      initializePagination();
    } else {
      // Merge all pages back into full content
      if (pages.length > 0) {
        // Update current page with editor content
        if (pages[currentPageIndex]) {
          pages[currentPageIndex].content = editor.value;
        }
        fullContent = rebuildFullContent();
      } else {
        fullContent = editor.value;
      }
      
      // Show full content in editor
      editor.value = fullContent;
      pages = [{ content: fullContent, startIndex: 0 }];
      currentPageIndex = 0;
      updatePaginationState();
      updatePreview();
    }
    
    // Show/hide page size controls
    desktopPageSizeRow.style.display = enabled && !window.matchMedia('(max-width: 768px)').matches ? 'grid' : 'none';
    mobilePageSizeRow.style.display = enabled && window.matchMedia('(max-width: 768px)').matches ? 'grid' : 'none';
  }
  
  function updatePageSizeRowVisibility() {
    if (!paginationEnabled) {
      desktopPageSizeRow.style.display = 'none';
      mobilePageSizeRow.style.display = 'none';
      return;
    }
    
    const isMobile = window.matchMedia('(max-width: 768px)').matches;
    desktopPageSizeRow.style.display = isMobile ? 'none' : 'grid';
    mobilePageSizeRow.style.display = isMobile ? 'grid' : 'none';
  }
  
  function updatePageSizeDisplay(slider) {
    if (slider.nextElementSibling) {
      slider.nextElementSibling.textContent = parseInt(slider.value).toLocaleString();
    }
  }
  
  function jumpToLastPageAndScrollToBottom() {
    if (!paginationEnabled || pages.length === 0) {
      return;
    }
    
    // Switch to last page
    switchToPage(pages.length - 1);
    
    // Scroll to bottom of editor
    setTimeout(() => {
      editor.scrollTop = editor.scrollHeight;
      editor.focus();
      editor.setSelectionRange(editor.value.length, editor.value.length);
    }, 50);
  }

  async function saveAISettings(isUserAction = true) {
    if (!accessToken) return;
    
    try {
      const settings = {
        ai_model: aiModel.value || "",
        remember_key: !!rememberKey.checked,
        openrouter_key: rememberKey.checked ? (openrouterKey.value || "") : "",
        // AI parameters
        max_tokens: parseInt(maxOutputTokensInput.value) || 1000,
        max_input_characters: parseInt(maxInputCharactersInput.value) || 32000,
        temperature: parseFloat(temperatureInput.value) || 0.7,
        top_p: parseFloat(topPInput.value) || 1.0,
        top_k: parseInt(topKInput.value) || 0,
        clean_ai_output: !!cleanAIOutput.checked,
        // Display preferences
        theme: themeSelect.value || "light",
        font_family: fontFamilySelect.value || "mono",
        font_size_desktop: parseInt(fontSizeDesktop.value) || 14,
        font_size_mobile: parseInt(fontSizeMobile.value) || 14,
        // Pagination preferences
        pagination_enabled: !!paginationEnabledCheckbox.checked,
        page_size_desktop: parseInt(pageSizeDesktop.value) || 20000,
        page_size_mobile: parseInt(pageSizeMobile.value) || 10000,
        last_updated: new Date().toISOString()
      };
      
      const settingsJson = JSON.stringify(settings, null, 2);
      
      if (aiSettingsFileId) {
        // Update existing file
        const res = await fetch(`${DRIVE_UPLOAD_URL}/${aiSettingsFileId}?uploadType=media`, {
          method: "PATCH",
          headers: { ...authHeader(), "Content-Type": "application/json; charset=UTF-8" },
          body: settingsJson
        });
        if (res.status === 401) { await handleUnauthorized(isUserAction); return saveAISettings(isUserAction); }
        if (!res.ok) throw new Error(`Update AI settings failed: ${res.status}`);
      } else {
        // Create new file in appdata folder
        const boundary = "-------AISettings-" + Math.random().toString(36).slice(2);
        const metadata = { 
          name: AI_SETTINGS_FILENAME, 
          parents: ["appdata"],
          mimeType: "application/json"
        };
        const body = `--${boundary}\r\n` +
          `Content-Type: application/json; charset=UTF-8\r\n\r\n` +
          JSON.stringify(metadata) + `\r\n` +
          `--${boundary}\r\n` +
          `Content-Type: application/json; charset=UTF-8\r\n\r\n` +
          settingsJson + `\r\n` +
          `--${boundary}--`;
          
        const res = await fetch(`${DRIVE_UPLOAD_URL}?uploadType=multipart&fields=id`, {
          method: "POST",
          headers: { ...authHeader(), "Content-Type": `multipart/related; boundary=${boundary}` },
          body
        });
        if (res.status === 401) { await handleUnauthorized(isUserAction); return saveAISettings(isUserAction); }
        if (!res.ok) throw new Error(`Create AI settings failed: ${res.status}`);
        
        const result = await res.json();
        aiSettingsFileId = result.id;
      }
      
      console.log("AI settings saved to Drive");
    } catch (e) {
      console.warn("Failed to save AI settings:", e);
    }
  }

  // =========================
  //  Drive helpers (fetch)
  // =========================
  function authHeader() { return { Authorization: `Bearer ${accessToken}` }; }
  async function createTextFile(name, text, isUserAction = true) { const boundary = "-------Ghostwriter-" + Math.random().toString(36).slice(2); const metadata = { name, mimeType: "text/plain", appProperties: { Ghostwriter: "1" } }; const body = `--${boundary}\r\n` + `Content-Type: application/json; charset=UTF-8\r\n\r\n` + JSON.stringify(metadata) + `\r\n` + `--${boundary}\r\n` + `Content-Type: text/plain; charset=UTF-8\r\n\r\n` + (text || "") + `\r\n` + `--${boundary}--`; const res = await fetch(`${DRIVE_UPLOAD_URL}?uploadType=multipart&fields=id,name,webViewLink,modifiedTime`, { method: "POST", headers: { ...authHeader(), "Content-Type": `multipart/related; boundary=${boundary}` }, body }); if (res.status === 401) { await handleUnauthorized(isUserAction); return createTextFile(name, text, isUserAction); } if (!res.ok) throw new Error(`Create failed: ${res.status}`); return await res.json(); }
  async function updateTextFile(fileId, text, isUserAction = true) { const res = await fetch(`${DRIVE_UPLOAD_URL}/${fileId}?uploadType=media&fields=id,name,modifiedTime,webViewLink`, { method: "PATCH", headers: { ...authHeader(), "Content-Type": "text/plain; charset=UTF-8" }, body: text || "" }); if (res.status === 401) { await handleUnauthorized(isUserAction); return updateTextFile(fileId, text, isUserAction); } if (!res.ok) throw new Error(`Update failed: ${res.status}`); return await res.json(); }
  async function downloadTextFile(fileId, isUserAction = true) { const res = await fetch(`${DRIVE_FILES_URL}/${fileId}?alt=media`, { headers: authHeader() }); if (res.status === 401) { await handleUnauthorized(isUserAction); return downloadTextFile(fileId, isUserAction); } if (!res.ok) throw new Error(`Download failed: ${res.status}`); return await res.text(); }
  async function getMeta(fileId, isUserAction = true) { const res = await fetch(`${DRIVE_FILES_URL}/${fileId}?fields=id,name,modifiedTime`, { headers: authHeader() }); if (res.status === 401) { await handleUnauthorized(isUserAction); return getMeta(fileId, isUserAction); } if (!res.ok) throw new Error(`Meta failed: ${res.status}`); return await res.json(); }
  async function renameFile(fileId, newName, isUserAction = true) { const res = await fetch(`${DRIVE_FILES_URL}/${fileId}?fields=id,name,modifiedTime`, { method: "PATCH", headers: { ...authHeader(), "Content-Type": "application/json" }, body: JSON.stringify({ name: newName }) }); if (res.status === 401) { await handleUnauthorized(isUserAction); return renameFile(fileId, newName, isUserAction); } if (!res.ok) throw new Error(`Rename failed: ${res.status}`); return await res.json(); }
  async function listGhostwriterFiles(isUserAction = true) { const q = ["mimeType='text/plain'","appProperties has { key='Ghostwriter' and value='1' }"]; const url = new URL(DRIVE_FILES_URL); url.searchParams.set("q", q.join(" and ")); url.searchParams.set("orderBy", "modifiedTime desc"); url.searchParams.set("pageSize", "100"); url.searchParams.set("fields", "files(id,name,modifiedTime)"); const res = await fetch(url.toString(), { headers: authHeader() }); if (res.status === 401) { await handleUnauthorized(isUserAction); return listGhostwriterFiles(isUserAction); } if (!res.ok) throw new Error(`List failed: ${res.status}`); const { files } = await res.json(); return files || []; }
  async function refreshToken(isUserAction = false){ 
    // Prevent concurrent refresh attempts
    if (isRefreshingToken) {
      throw new Error("Token refresh already in progress");
    }
    
    // Only allow popups for user actions or when background refresh is explicitly allowed
    if (!isUserAction && !allowBackgroundRefresh) {
      // Clear invalid token and show signed out state
      accessToken = null;
      deleteCookie('ghostwriter_auth');
      setSignedInUI(false);
      setStatus("Session expired. Please sign in again.");
      throw new Error("Session expired - background refresh not allowed");
    }
    
    isRefreshingToken = true;
    
    return new Promise((resolve, reject) => { 
      const originalCallback = tokenClient.callback;
      tokenClient.callback = (resp) => {
        isRefreshingToken = false;
        if (resp.error) { 
          console.error(resp); 
          // Clear invalid token and show signed out state
          accessToken = null;
          deleteCookie('ghostwriter_auth');
          setSignedInUI(false);
          setStatus("Auth error."); 
          tokenClient.callback = originalCallback;
          reject(new Error(resp.error));
          return; 
        }
        accessToken = resp.access_token;
        setCookie('ghostwriter_auth', accessToken, 1); // Save for 1 day
        setStatus("Signed in.");
        setSignedInUI(true);
        tokenClient.callback = originalCallback;
        resolve();
      };
      tokenClient.requestAccessToken({ prompt: "" }); 
    }); 
  }

  // Helper function for handling 401 errors in background operations
  async function handleUnauthorized(isUserAction = false) {
    if (isUserAction) {
      // For user actions, attempt to refresh the token
      return await refreshToken(true);
    } else {
      // For background operations, silently fail and clear token
      accessToken = null;
      deleteCookie('ghostwriter_auth');
      setSignedInUI(false);
      setStatus("Session expired. Please sign in again.");
      throw new Error("Session expired");
    }
  }

  // =========================
  //  App actions (now include JSON header)
  // =========================
  async function createNewFile() {
    try {
      setStatus("Creating file…");
      const title = `GhostWriter ${new Date().toISOString().replace(/[:.]/g, "-")}.txt`;
      const combined = buildFileText(readMetaFromUI(), getFullContent() || "");
      const meta = await createTextFile(title, combined, true); // user action
      setActiveFile(meta.id, meta.name);
      lastRemoteModified = Date.parse(meta.modifiedTime || Date.now());
      startPolling();
      setStatus("File created and syncing.");
      const u = new URL(location.href); u.searchParams.set("file", meta.id); history.replaceState({}, "", u.toString());
      updatePreview();
    } catch (e) { console.error(e); setStatus("Failed to create file. See console."); }
  }

  async function saveAsFile() {
    try {
      // Prompt user for filename
      const newFilename = prompt("Enter filename for Save As:", "");
      if (!newFilename || !newFilename.trim()) {
        setStatus("Save As cancelled.");
        return;
      }
      
      const trimmedFilename = newFilename.trim();
      setStatus("Checking for existing files…");
      
      // Check if file with this name already exists
      const existingFiles = await listGhostwriterFiles(true);
      const conflictingFile = existingFiles.find(f => f.name === trimmedFilename);
      
      if (conflictingFile) {
        const overwrite = confirm(`A file named "${trimmedFilename}" already exists. Do you want to overwrite it?`);
        if (!overwrite) {
          setStatus("Save As cancelled.");
          return;
        }
      }
      
      setStatus("Saving file with new name…");
      const combined = buildFileText(readMetaFromUI(), getFullContent() || "");
      
      let meta;
      if (conflictingFile) {
        // Overwrite existing file
        meta = await updateTextFile(conflictingFile.id, combined, true);
        meta.name = trimmedFilename; // Ensure name is correct
      } else {
        // Create new file
        meta = await createTextFile(trimmedFilename, combined, true);
      }
      
      setActiveFile(meta.id, meta.name);
      lastRemoteModified = Date.parse(meta.modifiedTime || Date.now());
      startPolling();
      setStatus("File saved with new name and syncing.");
      const u = new URL(location.href); u.searchParams.set("file", meta.id); history.replaceState({}, "", u.toString());
      updatePreview();
    } catch (e) { 
      console.error(e); 
      setStatus("Save As failed. See console."); 
    }
  }

  async function newDocument() {
    try {
      // Save current work first if there's a file loaded and content exists
      if (currentFileId && (getFullContent() || "").trim()) {
        setStatus("Saving current work…");
        await flushSave({ force: true, isUserAction: true });
      } else if (!currentFileId && (getFullContent() || "").trim()) {
        // If no current file but there's content, prompt to save first
        const shouldSave = confirm("You have unsaved content. Would you like to save it before creating a new document?");
        if (shouldSave) {
          await saveAsFile();
          if (!currentFileId) {
            // If save was cancelled, don't proceed with new document
            return;
          }
        }
      }
      
      setStatus("Creating new document…");
      
      // Clear all content
      editor.value = "";
      
      // Reset undo generation state
      lastContentBeforeGeneration = null;
      hasUndoableGeneration = false;
      contentChangedSinceGeneration = false;
      undoGenerateBtn.classList.remove('visible');
      
      // Clear Story Dex
      currentStoryDex = [];
      renderStoryDex();
      
      // Clear metadata and set default pre-prompt for new documents
      aiPreInput.value = getDefaultAIPrePrompt();
      nextInstInput.value = "";
      nextEnabled.checked = false;
      
      // Clear active file
      setActiveFile(null, null);
      
      // Clear URL parameter
      const u = new URL(location.href); 
      u.searchParams.delete("file"); 
      history.replaceState({}, "", u.toString());
      
      // Stop polling since there's no active file
      stopPolling();
      
      // Update preview
      updatePreview();
      
      // Reset pagination if enabled
      if (paginationEnabled) {
        fullContent = "";
        initializePagination();
      }
      
      setStatus("New document ready.");
    } catch (e) { 
      console.error(e); 
      setStatus("Failed to create new document. See console."); 
    }
  }

  async function loadFile(id) {
    try {
      setStatus("Loading file…");
      const meta = await getMeta(id, true); // user action
      const raw = await downloadTextFile(id, true); // user action
      const parsed = parseFileText(raw);
      writeMetaToUI(parsed.meta);
      editor.value = parsed.content;
      
      // Reset undo generation state when loading a file
      lastContentBeforeGeneration = null;
      hasUndoableGeneration = false;
      contentChangedSinceGeneration = false;
      undoGenerateBtn.classList.remove('visible');
      
      // Initialize pagination with loaded content
      fullContent = parsed.content;
      if (paginationEnabled) {
        initializePagination();
      } else {
        updatePaginationState(); // Ensure pagination UI is hidden
      }
      
      setActiveFile(id, meta.name || "(unknown)");
      lastRemoteModified = Date.parse(meta.modifiedTime || 0);
      startPolling();
      setStatus("Loaded and syncing.");
      const u = new URL(location.href); u.searchParams.set("file", id); history.replaceState({}, "", u.toString());
      updatePreview();
    } catch (e) { console.error(e); setStatus("Failed to load file. Check ID and permissions."); }
  }

  function scheduleAutosave(){ clearTimeout(autosaveTimer); autosaveTimer = setTimeout(() => flushSave(), AUTOSAVE_DELAY); }

  // Get the full content
  function getFullContent() {
    if (!paginationEnabled) {
      return editor.value;
    }
    
    // Update current page with editor content
    if (pages[currentPageIndex]) {
      pages[currentPageIndex].content = editor.value;
    }
    
    // Return merged content from all pages
    return rebuildFullContent();
  }

  async function flushSave(opts={}) {
    if (!currentFileId || !accessToken) return;
    if (!dirty && !opts.force) return;
    try {
      isSaving = true; setSaveDot("saving"); if (!opts.silent) setStatus("Saving…");
      const combined = buildFileText(readMetaFromUI(), getFullContent());
      // Determine if this is a user action (manual save) or auto-save
      const isUserAction = opts.isUserAction !== undefined ? opts.isUserAction : false;
      const res = await updateTextFile(currentFileId, combined, isUserAction);
      lastRemoteModified = Date.parse(res.modifiedTime || Date.now());
      dirty = false; isSaving = false; setSaveDot("saved"); if (!opts.silent) setStatus("Saved.");
      syncNote.textContent = `Auto-saved at ${new Date().toLocaleTimeString()}`;
      setTimeout(() => { if (!dirty) setSaveDot("idle"); }, 1200);
    } catch (e) { 
      console.error(e); 
      isSaving = false; 
      setSaveDot("idle"); 
      setStatus("Save failed. Will retry on next edit."); 
      // Stop polling if authentication failed during auto-save
      if (e.message.includes("Session expired")) {
        stopPolling();
      }
    }
  }

  function startPolling(){ stopPolling(); pollTimer = setInterval(checkRemoteChanges, POLL_INTERVAL); }
  function stopPolling(){ if (pollTimer) clearInterval(pollTimer); pollTimer = null; }

  async function checkRemoteChanges(){
    if (!currentFileId || !accessToken) return;
    const now = Date.now();
    if (isSaving) return;
    if (dirty && now - lastInputTs < IDLE_GRACE) return;
    try {
      const meta = await getMeta(currentFileId, false); // background operation
      const remoteTs = Date.parse(meta.modifiedTime || 0);
      if (remoteTs > lastRemoteModified && !dirty) {
        const raw = await downloadTextFile(currentFileId, false); // background operation
        const parsed = parseFileText(raw);
        writeMetaToUI(parsed.meta);
        editor.value = parsed.content;
        
        // Update pagination with pulled content
        fullContent = parsed.content;
        if (paginationEnabled) {
          initializePagination();
        }
        
        lastRemoteModified = remoteTs;
        syncNote.textContent = `Updated from Drive at ${new Date().toLocaleTimeString()}`;
        setStatus("Pulled latest changes from Drive.");
        updatePreview();
      }
    } catch (e) { 
      console.warn("Polling error", e); 
      // Stop polling if authentication failed
      if (e.message.includes("Session expired")) {
        stopPolling();
      }
    }
  }

  async function refreshList() {
    try { 
      setStatus("Listing files…"); 
      const files = await listGhostwriterFiles(true); // user action
      listBody.innerHTML = files.map(f => { 
        const when = new Date(f.modifiedTime).toLocaleString(); 
        const openHere = `<button data-open="${f.id}">Open here</button>`; 
        const rename = `<button data-rename="${f.id}">Rename</button>`;
        const link = `https://drive.google.com/file/d/${f.id}/view`; 
        return `<tr><td>${escapeHtml(f.name)}</td><td>${when}</td><td>${openHere} ${rename} <a href="${link}" target="_blank" rel="noreferrer">Drive</a></td></tr>`; 
      }).join(""); 
      listBody.querySelectorAll("button[data-open]").forEach(btn => { 
        btn.addEventListener("click", () => loadFile(btn.getAttribute("data-open"))); 
      }); 
      listBody.querySelectorAll("button[data-rename]").forEach(btn => { 
        btn.addEventListener("click", () => promptRenameFile(btn.getAttribute("data-rename"))); 
      }); 
      setStatus("Ready."); 
    } catch (e) { 
      console.error(e); 
      setStatus("List failed. See console."); 
    }
  }

  async function promptRenameFile(fileId) {
    try {
      // Get current file info
      const fileInfo = await getMeta(fileId, true); // user action
      const newName = prompt('Enter new filename:', fileInfo.name);
      
      if (newName && newName.trim() && newName !== fileInfo.name) {
        setStatus("Renaming file…");
        await renameFile(fileId, newName.trim(), true); // user action
        
        // Update the current file name if this is the active file
        if (currentFileId === fileId) {
          currentFileName = newName.trim();
          activeFileEl.textContent = currentFileName;
        }
        
        // Refresh the file list to show the new name
        await refreshList();
        setStatus("File renamed successfully.");
      }
    } catch (e) {
      console.error(e);
      setStatus("Rename failed. See console.");
    }
  }

  // NOTE: This overrides the earlier one (intentionally more strict for list rendering)
  function escapeHtml(str){ return String(str).replaceAll('&','&amp;').replaceAll('<','&lt;').replaceAll('>','&gt;').replaceAll('"','&quot;').replaceAll("'", '&#039;'); }
</script>
</body>
</html>
