<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Ghostwriter POC — Drive-only Sync (Plain Text)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <!-- Google Identity Services (OAuth in browser) -->
  <script src="https://accounts.google.com/gsi/client" async defer></script>
  <style>
    :root { --bg:#ffffff; --muted:#f6f6f6; --line:#e8e8e8; --ink:#111; --sub:#555; }
    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body { margin: 0; background: var(--bg); color: var(--ink); font: 14px/1.45 system-ui, -apple-system, Segoe UI, Roboto, sans-serif; }
    .app { display: grid; grid-template-rows: auto 1fr auto; height: 100vh; }
    header, footer { background: var(--muted); border-bottom: 1px solid var(--line); }
    footer { border-top: 1px solid var(--line); border-bottom: none; font-size: 12px; color: var(--sub); padding: 10px 14px; display:flex; gap:10px; align-items:center; }
    .toolbar { padding: 10px 14px; display: flex; gap: 8px; flex-wrap: wrap; align-items: center; }
    .toolbar button { padding: 8px 10px; border: 1px solid var(--line); background: #fff; border-radius: 10px; cursor: pointer; }
    .toolbar button[disabled] { opacity: 0.5; cursor: not-allowed; }
    .toolbar input[type="text"] { flex: 1; min-width: 220px; padding: 8px; border-radius: 10px; border: 1px solid var(--line); background: #fff; }
    #editor { width: 100%; height: 100%; padding: 16px; border: none; outline: none; resize: none; font: 14px/1.5 ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; }
    .pill { display: inline-block; padding: 3px 10px; border-radius: 999px; background: #eee; font-size: 12px; }
    .row { display: flex; align-items: center; gap: 8px; flex-wrap: wrap; }
    #list-panel { max-height: 40vh; overflow: auto; border-top: 1px solid var(--line); background: #fff; display: none; }
    #list-panel table { width: 100%; border-collapse: collapse; font-size: 13px; }
    #list-panel th, #list-panel td { padding: 8px 12px; border-bottom: 1px solid var(--line); }
    #list-panel tr:hover { background: #fafafa; }
    a { color: inherit; }
    code.kbd { padding: 2px 6px; border: 1px solid var(--line); border-radius: 6px; background: #fbfbfb; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; }
    .dot { width:8px; height:8px; border-radius:999px; background:#bbb; display:inline-block; }
    .dot.saving { background:#d69e2e; }
    .dot.saved { background:#38a169; }
    .dot.idle { background:#bbb; }
  </style>
</head>
<body>
<div class="app">
  <header>
    <div class="toolbar">
      <div class="row">
        <button id="auth-btn">Sign in</button>
        <button id="signout-btn" disabled>Sign out</button>
        <span class="pill" id="auth-state">Signed out</span>
      </div>
      <div class="row">
        <button id="create-file-btn" disabled>Create new file</button>
        <input id="file-id-input" type="text" placeholder="Paste File ID and press Enter (or use ?file=...)" />
        <button id="list-btn" disabled>My files</button>
      </div>
    </div>
    <div id="list-panel">
      <table>
        <thead><tr><th style="width:45%">Name</th><th style="width:35%">Modified</th><th style="width:20%">Actions</th></tr></thead>
        <tbody id="list-body"></tbody>
      </table>
    </div>
  </header>

  <textarea id="editor" placeholder="Write your story here…"></textarea>

  <footer>
    <span id="status">Ready.</span>
    <span id="active-file"></span>
    <span class="dot idle" id="save-indicator" title="Save status"></span>
    <span class="pill" id="sync-note"></span>
  </footer>
</div>

<script>
  // =========================
  //  Configuration
  // =========================
  // OAuth 2.0 Web client ID (public identifier)
  const CLIENT_ID = "389780383024-03s13biqo3n1hvdv2mn8jb2fcvc17ks3.apps.googleusercontent.com";
  // Narrow Drive scope: create/read/update files this app created or explicitly opened with it.
  const SCOPE = "https://www.googleapis.com/auth/drive.file";

  // Drive REST endpoints
  const DRIVE_UPLOAD_URL = "https://www.googleapis.com/upload/drive/v3/files";
  const DRIVE_FILES_URL  = "https://www.googleapis.com/drive/v3/files";

  // Autosave + polling
  const AUTOSAVE_DELAY = 1200;     // ms after last keystroke
  const POLL_INTERVAL  = 8000;     // ms between remote checks
  const IDLE_GRACE     = 1200;     // ms considered "still typing"

  // =========================
  //  DOM
  // =========================
  const authBtn      = document.getElementById("auth-btn");
  const signoutBtn   = document.getElementById("signout-btn");
  const createBtn    = document.getElementById("create-file-btn");
  const listBtn      = document.getElementById("list-btn");
  const fileIdInput  = document.getElementById("file-id-input");
  const editor       = document.getElementById("editor");
  const statusEl     = document.getElementById("status");
  const authStateEl  = document.getElementById("auth-state");
  const activeFileEl = document.getElementById("active-file");
  const listPanel    = document.getElementById("list-panel");
  const listBody     = document.getElementById("list-body");
  const saveDot      = document.getElementById("save-indicator");
  const syncNote     = document.getElementById("sync-note");

  // =========================
  //  Auth & state
  // =========================
  let tokenClient = null;
  let accessToken = null; // kept in-memory only
  let currentFileId = null;
  let currentFileName = null;
  let autosaveTimer = null;
  let pollTimer = null;
  let isSaving = false;
  let dirty = false;           // local edits since last save
  let lastInputTs = 0;         // timestamp of last keystroke
  let lastRemoteModified = 0;  // ms
  let lastRemoteMd5 = null;

  function setStatus(msg) { statusEl.textContent = msg; }
  function setSaveDot(state) {
    saveDot.classList.remove("saving","saved","idle");
    saveDot.classList.add(state);
  }
  function setActiveFile(id, name) {
    currentFileId = id || null;
    currentFileName = name || null;
    fileIdInput.value = id || "";
    activeFileEl.textContent = id ? `• File: ${name || "(untitled)"} — ID: ${id}` : "";
  }
  function setSignedInUI(signedIn) {
    authStateEl.textContent = signedIn ? "Signed in" : "Signed out";
    createBtn.disabled = !signedIn;
    signoutBtn.disabled = !signedIn;
    listBtn.disabled = !signedIn;
    fileIdInput.disabled = !signedIn;
  }
  function getQueryFileId() {
    const p = new URLSearchParams(location.search);
    return p.get("file");
  }

  window.addEventListener("load", () => {
    // Wait for GIS to be present
    const waitFor = (cond) => new Promise(res => { const t = () => cond() ? res() : setTimeout(t, 50); t(); });
    waitFor(() => window.google && google.accounts && google.accounts.oauth2).then(() => {
      tokenClient = google.accounts.oauth2.initTokenClient({
        client_id: CLIENT_ID,
        scope: SCOPE,
        callback: (resp) => {
          if (resp.error) { console.error(resp); setStatus("Auth error."); return; }
          accessToken = resp.access_token;
          setStatus("Signed in.");
          setSignedInUI(true);
          // Auto-open if ?file= is present
          const preset = getQueryFileId();
          if (preset) { fileIdInput.value = preset; loadFile(preset); }
        }
      });
      wireEvents();
      setStatus("Ready. Sign in to begin.");
    }).catch(err => { console.error(err); setStatus("Failed to initialize Google Identity Services."); });
  });

  function ensureAuth(action, fn) {
    return () => {
      if (!accessToken) {
        setStatus(`Requesting permission for ${action}…`);
        tokenClient.requestAccessToken({ prompt: "consent" });
        return;
      }
      fn();
    };
  }

  function wireEvents() {
    authBtn.addEventListener("click", () => {
      setStatus("Opening Google sign-in…");
      tokenClient.requestAccessToken({ prompt: "consent" });
    });
    signoutBtn.addEventListener("click", () => {
      if (accessToken) {
        stopPolling();
        google.accounts.oauth2.revoke(accessToken, () => {
          accessToken = null;
          setSignedInUI(false);
          setActiveFile(null, null);
          setStatus("Signed out.");
        });
      }
    });

    createBtn.addEventListener("click", ensureAuth("creating a file", createNewFile));

    // Paste an ID and press Enter to open
    fileIdInput.addEventListener("keydown", (e) => {
      if (e.key === "Enter") {
        const id = fileIdInput.value.trim();
        if (id) ensureAuth("opening a file", () => loadFile(id))();
      }
    });

    listBtn.addEventListener("click", ensureAuth("listing files", async () => {
      listPanel.style.display = listPanel.style.display === "none" ? "block" : "none";
      if (listPanel.style.display === "block") {
        await refreshList();
      }
    }));

    // Typing: mark dirty and schedule autosave
    editor.addEventListener("input", () => {
      dirty = true;
      lastInputTs = Date.now();
      setSaveDot("saving");
      scheduleAutosave();
    });

    // Try to flush on tab close/background
    window.addEventListener("visibilitychange", () => { if (document.visibilityState === "hidden") flushSave({ silent:true }); });
    window.addEventListener("beforeunload", () => { flushSave({ silent:true }); });

    // Power-user: Ctrl/⌘+S forces an immediate save
    window.addEventListener("keydown", (e) => {
      const isMeta = navigator.platform.toLowerCase().includes("mac") ? e.metaKey : e.ctrlKey;
      if (isMeta && e.key.toLowerCase() === "s") {
        e.preventDefault();
        flushSave();
      }
    });
  }

  // =========================
  //  Drive helpers (fetch)
  // =========================
  function authHeader() { return { Authorization: `Bearer ${accessToken}` }; }

  async function createTextFile(name, text) {
    const boundary = "-------storypad-" + Math.random().toString(36).slice(2);
    const metadata = { name, mimeType: "text/plain", appProperties: { storypad: "1" } };
    const body =
      `--${boundary}
` +
      `Content-Type: application/json; charset=UTF-8

` +
      JSON.stringify(metadata) + `
` +
      `--${boundary}
` +
      `Content-Type: text/plain; charset=UTF-8

` +
      (text || "") + `
` +
      `--${boundary}--`;

    const res = await fetch(`${DRIVE_UPLOAD_URL}?uploadType=multipart&fields=id,name,webViewLink,modifiedTime`, {
      method: "POST",
      headers: { ...authHeader(), "Content-Type": `multipart/related; boundary=${boundary}` },
      body
    });
    if (res.status === 401) { await refreshToken(); return createTextFile(name, text); }
    if (!res.ok) throw new Error(`Create failed: ${res.status}`);
    return await res.json();
  }

  async function updateTextFile(fileId, text) {
    const res = await fetch(`${DRIVE_UPLOAD_URL}/${fileId}?uploadType=media&fields=id,name,modifiedTime,webViewLink`, {
      method: "PATCH",
      headers: { ...authHeader(), "Content-Type": "text/plain; charset=UTF-8" },
      body: text || ""
    });
    if (res.status === 401) { await refreshToken(); return updateTextFile(fileId, text); }
    if (!res.ok) throw new Error(`Update failed: ${res.status}`);
    return await res.json();
  }

  async function downloadTextFile(fileId) {
    const res = await fetch(`${DRIVE_FILES_URL}/${fileId}?alt=media`, { headers: authHeader() });
    if (res.status === 401) { await refreshToken(); return downloadTextFile(fileId); }
    if (!res.ok) throw new Error(`Download failed: ${res.status}`);
    return await res.text();
  }

  async function getMeta(fileId) {
    const res = await fetch(`${DRIVE_FILES_URL}/${fileId}?fields=id,name,modifiedTime,md5Checksum`, { headers: authHeader() });
    if (res.status === 401) { await refreshToken(); return getMeta(fileId); }
    if (!res.ok) throw new Error(`Meta failed: ${res.status}`);
    return await res.json();
  }

  async function listStorypadFiles() {
    const q = ["mimeType='text/plain'","appProperties has { key='storypad' and value='1' }"]; // only our files
    const url = new URL(DRIVE_FILES_URL);
    url.searchParams.set("q", q.join(" and "));
    url.searchParams.set("orderBy", "modifiedTime desc");
    url.searchParams.set("pageSize", "100");
    url.searchParams.set("fields", "files(id,name,modifiedTime)");
    const res = await fetch(url.toString(), { headers: authHeader() });
    if (res.status === 401) { await refreshToken(); return listStorypadFiles(); }
    if (!res.ok) throw new Error(`List failed: ${res.status}`);
    const { files } = await res.json();
    return files || [];
  }

  async function refreshToken(){
    return new Promise((resolve) => {
      tokenClient.callback = () => resolve();
      tokenClient.requestAccessToken({ prompt: "" }); // silent refresh
    });
  }

  // =========================
  //  App actions
  // =========================
  async function createNewFile() {
    try {
      setStatus("Creating file…");
      const title = `StoryPad ${new Date().toISOString().replace(/[:.]/g, "-")}.txt`;
      const meta = await createTextFile(title, editor.value || "");
      setActiveFile(meta.id, meta.name);
      lastRemoteModified = Date.parse(meta.modifiedTime || Date.now());
      startPolling();
      setStatus("File created and syncing.");
      // Update URL
      const u = new URL(location.href);
      u.searchParams.set("file", meta.id);
      history.replaceState({}, "", u.toString());
    } catch (e) { console.error(e); setStatus("Failed to create file. See console."); }
  }

  async function loadFile(id) {
    try {
      setStatus("Loading file…");
      // Get metadata first to track remote state
      const meta = await getMeta(id);
      const text = await downloadTextFile(id);
      editor.value = text;
      setActiveFile(id, meta.name || "(unknown)");
      lastRemoteModified = Date.parse(meta.modifiedTime || 0);
      lastRemoteMd5 = meta.md5Checksum || null;
      startPolling();
      setStatus("Loaded and syncing.");
      const u = new URL(location.href);
      u.searchParams.set("file", id);
      history.replaceState({}, "", u.toString());
    } catch (e) { console.error(e); setStatus("Failed to load file. Check ID and permissions."); }
  }

  function scheduleAutosave(){
    clearTimeout(autosaveTimer);
    autosaveTimer = setTimeout(() => flushSave(), AUTOSAVE_DELAY);
  }

  async function flushSave(opts={}) {
    if (!currentFileId || !accessToken) return;
    if (!dirty && !opts.force) return;
    try {
      isSaving = true;
      setSaveDot("saving");
      if (!opts.silent) setStatus("Saving…");
      const res = await updateTextFile(currentFileId, editor.value);
      lastRemoteModified = Date.parse(res.modifiedTime || Date.now());
      dirty = false;
      isSaving = false;
      setSaveDot("saved");
      if (!opts.silent) setStatus("Saved.");
      // Clear note after a moment
      syncNote.textContent = `Auto-saved at ${new Date().toLocaleTimeString()}`;
      setTimeout(() => { if (!dirty) setSaveDot("idle"); }, 1200);
    } catch (e) {
      console.error(e);
      isSaving = false;
      setSaveDot("idle");
      setStatus("Save failed. Will retry on next edit.");
    }
  }

  function startPolling(){
    stopPolling();
    pollTimer = setInterval(checkRemoteChanges, POLL_INTERVAL);
  }
  function stopPolling(){ if (pollTimer) clearInterval(pollTimer); pollTimer = null; }

  async function checkRemoteChanges(){
    if (!currentFileId || !accessToken) return;
    // don't interrupt active typing or saving
    const now = Date.now();
    if (isSaving) return;
    if (dirty && now - lastInputTs < IDLE_GRACE) return;

    try {
      const meta = await getMeta(currentFileId);
      const remoteTs = Date.parse(meta.modifiedTime || 0);
      const remoteMd5 = meta.md5Checksum || null;

      // Only pull when remote changed and we're idle
      if (remoteTs > lastRemoteModified && !dirty) {
        const text = await downloadTextFile(currentFileId);
        editor.value = text;
        lastRemoteModified = remoteTs;
        lastRemoteMd5 = remoteMd5;
        syncNote.textContent = `Updated from Drive at ${new Date().toLocaleTimeString()}`;
        setStatus("Pulled latest changes from Drive.");
      }
    } catch (e) {
      console.warn("Polling error", e);
    }
  }

  async function refreshList() {
    try {
      setStatus("Listing files…");
      const files = await listStorypadFiles();
      listBody.innerHTML = files.map(f => {
        const when = new Date(f.modifiedTime).toLocaleString();
        const openHere = `<button data-open="${f.id}">Open here</button>`;
        const link = `https://drive.google.com/file/d/${f.id}/view`;
        return `<tr><td>${escapeHtml(f.name)}</td><td>${when}</td><td>${openHere} <a href="${link}" target="_blank" rel="noreferrer">Drive</a></td></tr>`;
      }).join("");
      // Attach open handlers
      listBody.querySelectorAll("button[data-open]").forEach(btn => {
        btn.addEventListener("click", () => loadFile(btn.getAttribute("data-open")));
      });
      setStatus("Ready.");
    } catch (e) { console.error(e); setStatus("List failed. See console."); }
  }

  function escapeHtml(str){
    return String(str).replaceAll('&','&amp;').replaceAll('<','&lt;').replaceAll('>','&gt;').replaceAll('"','&quot;').replaceAll("'", '&#039;');
  }
</script>
</body>
</html>
